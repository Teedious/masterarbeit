\todo{Messwekzeuge nennen}
\todo{Hardware nennen}
Um den Effekt der Implementierung der nebenläufigen Architektur quantitativ analysieren zu können, werden einige Szenarien in der Blocklib definiert. Diese Szenarien werden werden dann in einem Stand vor der Integration der nebenläufigen Architektur und einem Stand danach durchlaufen. Da die Blocklib unter Nutzung des Versionsverwaltungstools Git~\cite{Chacon2014} entwickelt wird, lassen sich sogenannte Hashes angeben, die genau definieren, welche Versionen der Blocklib für die Performanceanalyse genutzt werden. Diese Hashes werden auch Revisionsnummern genannt. Die genutzten Hashes sind in Tabelle~\ref{tab:perfHash} aufgelistet.
\begin{table}
	\centering
	\begin{tabular}{ll}
		\toprule
		Stand & Hash / Revisionsnummer \\
		\midrule
		Nebenläufige Architektur & \texttt{110d0f9c227cb85d131c4f04fdf83b07ee218f39}\\
		Ursprüngliche Architektur & \texttt{d392933e558a9864ad71e7e3ccf8561f2c16b1b3} \\
		\bottomrule
	\end{tabular}
	\caption{Revisionsnummern des Versionsverwaltungstools der Blocklib, die für die Performanceanalyse genutzt werden.}\label{tab:perfHash}
\end{table}

Insgesamt werden fünf verschiedene Szenarien betrachtet. In allen Szenarien werden die folgenden Messwerte ausgewertet: \si{\fps}, Auslastung des Prozessors (CPU), Auslastung der Grafikkarte (GPU) und Speichernutzung. In jedem Szenario läuft die Blocklib für \SI{60}{\second}. Ausschlaggebend hierfür ist die durch Java mit der Methode \code{System.currentTimeMillis()} bereitgestellte Zeit. Der Code, der für die Ausführung der Szenarien benötigt wird, ist der Masterarbeit beigelegt.


\subsubsection{Szenario 1: Hexagon}
Um den Effekt der nebenläufigen Architektur möglichst zu isolieren, werden in den Szenarien 1 und 2 keine zufällig generierten Welten genutzt. Stattdessen werden die Blöcke nach einem festgelegten Muster gesetzt.

\begin{figure}
	\centering
	\includegraphics[width=.8\textwidth]{fps-hexagon.png}
	\caption{Screenshot der Blockformation in Szenario 1. Die Blöcke bilden ein stilisiertes Hexagon. Es ist \emph{nicht} gleichseitig. Die Formation ermöglicht den Blick auf je drei Seiten jedes Blocks und besteht aus 766 Blöcken.}\label{fig:hexagon}
\end{figure}
Die Anordnung der Blöcke in Szenario 1 ist in Abbildung~\ref{fig:hexagon} dargestellt. Wie auf der Abbildung bei genauem Hinsehen zu erkennen ist, sind von jedem Block drei Seiten sichtbar. Dadurch lässt sich die genaue Anzahl der Elemente bestimmen, die gezeichnet werden. Damit lässt sich die Gesamtzahl der gezeichneten Polygone\footnote{In der Blocklib besteht jedes gezeichnete Element aus Dreiecken oder aus Rechtecken, zusammenfassend werden diese als Polygone bezeichnet. Die meisten Elemente in der Welt werden als Dreiecke gezeichnet, die Elemente der graphischen Oberfläche nutzen Rechtecke. Jede Seite eines Blocks aus zwei Dreiecken hier aus zwei Dreiecken zusammengesetzt. Siehe dazu Auch Abbildung~\ref{fig:cube}.} für dieses Szenario genau berechnen. Jeden Frame müssen genau $766\cdot3\cdot2 + 3\cdot2-1 = 4596 +5 = 4601$ Polygone gezeichnet werden. Die $5$ zusätzlichen Polygone stammen von der \emph{Skybox}, einem großen Würfel um die Spielwelt herum, der eine Himmelstextur zeigt. Eines der Dreiecke der drei Seiten der Skybox ist außerhalb des Sichtfelds. Daher müssen nur $5$ Polygone hinzugezählt werden.

\begin{figure}[!htbp]
	\fpsplot{seed-0-hexagon}
	\caption{}\label{fig:seed-0-hexagon-fps}
\end{figure}
Abbildung~\ref{fig:seed-0-hexagon-fps} zeigt den Verlauf der \si{\fps}. Die Framerate unter SystemA ist durchschnittlich \SI{317}{\fps} unter SystemB \SI{1040}{\fps}. Das ist ein Zuwachs von \SI{228}{\percent}. Unter SystemA ist der Start der Blocklib schneller. Hier werden Frames nach \SI{11,2}{\second} erzeugt, in SystemB nach \SI{13,6}{\second}. SystemB benötigt für den Start also \SI{21}{\percent} mehr Zeit. Über die Zeit hinweg bleiben die Frameraten beider Systeme in etwa konstant.


\begin{figure}[!htbp]
	\cpuplot{seed-0-hexagon}
	\caption{}\label{fig:seed-0-hexagon-cpu}
\end{figure}
Der Verlauf der Auslastung der CPU durch die Blocklib ist in Abbildung~\ref{fig:seed-0-hexagon-cpu} zu sehen. Beide System zeigen hier eine Spitze in der Auslastung beim Start der Blocklib. In SystemA ist die maximale Auslastung von \SI{47}{\percent} nach \SI{11,6}{\second} erreicht, SystemB erreicht eine Auslastung von \SI{42}{\percent} nach \SI{15,6}{\second}. Die maximale Auslastung ist bei SystemB \SI{11}{\percent} niedriger als be SystemA. Die durchschnittliche Auslastung ist in SystemB mit einem Wert von \SI{19}{\percent} um \SI{38}{\percent} höher als in SystemB mit durchschnittlich \SI{14}{\percent}. Nach der anfänglichen Spitze ist die Auslastung in beiden System in etwa konstant.

\begin{figure}[!htbp]
	\gpuplot{seed-0-hexagon}
	\caption{}\label{fig:seed-0-hexagon-gpu}
\end{figure}
Der in Abbildung~\ref{fig:seed-0-hexagon-gpu} dargestellte Graph beschreibt die Auslastung der GPU im zeitlichen Verlauf. Da für diese Messungen ein externer Profiler genutzt wird, kann die Auslastung der GPU über die gesamte Messzeit hinweg ermittelt werden. Die Daten zu Beginn und zum Ende der Messung sind allerdings mit Vorsicht zu betrachten. So ist Auslastungsspitze zu Beginn der Messung nicht der Blocklib selbst zuzuordnen und zum Ende der Messung kann der Abfall der Auslastung nach Beendigung der Blocklib beobachtet werden. 

Da der GPU Profiler manuell gestartet werden muss, lassen sich die Auslastungswerte zu Beginn der Messung nicht gesichert vergleichen. Da der steile Abfall der Auslastung nach Beendigung der Blocklib bei beiden System gleichseitig ist, kann angenommen werden, dass zumindest grobe Trends zeitlich vergleichbar sind.

Auch in der Auslastung der GPU ist zu erkennen, dass der Start der Blocklib mit SystemA schneller ist als mit SystemB. Während in SystemA bereits nach \SI{7}{\second} eine Auslastungsspitze von \SI{27}{\percent} gemessen wird, ist der erste markante Anstieg der Auslastung (auf \SI{27}{\percent}) in SystemB  erst nach \SI{12}{\second} zu sehen. Die durchschnittliche Auslastung ist in beiden Systemen mit \SI{29,0}{\percent} in SystemA und \SI{29,3}{\percent} in SystemB fast identisch. Während in SystemB nach \SI{20}{\second} und dem Abschluss der Startphase die Auslastung fast konstant knapp unter \SI{40}{\percent} liegt, oszilliert die Auslastung in SystemA lange zwischen \SI{30}{\percent} und \SI{40}{\percent}, bis sie schließlich nach etwa \SI{50}{\second} ebenfalls konstant bei knapp \SI{40}{\percent} liegt.

\begin{figure}[!htbp]
	\memplot{seed-0-hexagon-single-mem.csv}
	\memplot{seed-0-hexagon-multi-mem.csv}
	\caption{}\label{fig:seed-0-hexagon-mem}
\end{figure} 
Betrachtet man den in Abbildung~\ref{fig:seed-0-hexagon-mem} gezeigten Vergleich der Speichernutzung zwischen SystemA und SystemB, lässt sich erkennen, dass SystemB sowohl während des Starts der Blocklib, als auch allgemein mehr Speicher benötigt, als SystemA. Der gelbe Bereich zeigt den von Java Insgesamt angeforderten Speicher. Zum Beginn ist das bei SystemB \SI{1730}{\mega\byte} und während des Großteils der Messung \SI{947}{\mega\byte}. System benötigt die ersten \SI{37}{\second} \SI{644}{\mega\byte} Speicher, was sich bis zum Ende der Messung auf \SI{382}{\mega\byte} verringert. Durchschnittlich benötigt SystemB mit \SI{991}{\mega\byte} \SI{71}{\percent} mehr Speicher als SystemA mit durchschnittlich \SI{581}{\mega\byte} Speicherbedarf.

Der rote Bereich zeigt den Speicherverbrauch kurzlebiger Objekte an. In SystemB steigt die Menge der neu erzeugten Objekte deutlich schneller an als in SystemA. Damit einher geht auch die Anzahl der durchgeführten \emph{Garbage Collections}\footnote{Wird ein Objekt in Java nicht mehr gebraucht, kann der Speicher wieder freigegeben werden. Das passiert automatisch durch den sogenannten Garbage Collector. Dieser wird nicht immer sofort tätig sondern nur zu bestimmten Situationen, insbesondere dann, wenn die freie Speichermenge zuneige geht.}. Die Spitzen in den roten Graphen markieren Zeiten zu denen der Garbage Collector aktiv geworden ist. In SystemA gibt es über die gesamte Messzeit 13 Garbage Collections, in SystemB sind es 21. Damit lässt sich abschätzen, dass SystemB kontinuierlich etwa \SI{61}{\percent} schneller Speicher mit neu erzeugten, kurzlebigen Objekten belegt als SystemA.

\subsubsection{Szenario 2: Halb-Würfel}
\begin{figure}
	\centering
	\includegraphics[width=.8\textwidth]{fps-cube.png}
	\caption{}\label{fig:cube}
\end{figure}
Da die Anzahl der zu zeichnenden Objekte in dem ersten Szenario relativ gering ist, wird diese in Szenario 2, das in Abbildung~\ref{fig:cube} veranschaulicht ist, erhöht. In diesem Szenario wird ein Bereich von $32 \times 32 \times 32$ Blöcken so befüllt, dass an jeder zweiten Stelle ein Block ist. Zweidimensional entspricht das einem Schachbrettmuster. Die Anzahl der platzierten Blöcke ist damit $\frac{1}{2}\cdot32^3 = 16384$. Die Anzahl der zu zeichnenden Dreiecke ist $16384\cdot6 + 5= = 98309$.

Aufgrund der Anordnung wären allerdings nur wenige Blöcke sichtbar. Daher wird das Drahtgittermodell gezeichnet, also nur die Kanten der zu zeichnenden Dreiecke. Dennoch kann hier nicht mehr sichergestellt werden, dass auch tatsächlich alle Elemente gezeichnet werden, da selbst mit dem Drahtgittermodell an vielen Stellen Polygone überdeckt werden. Durch die Dartstellung als Drahtgittermodell lassen sich nun auch die Kanten der Skybox erkennen und man sieht, dass das Dreiecke in der oberen rechten Ecke nicht mer gezeichnet wird.

\begin{figure}[!htbp]
	\fpsplot{seed-0-cube}
	\caption{}\label{fig:seed-0-cube-fps}
\end{figure}

\begin{figure}[!htbp]
	\cpuplot{seed-0-cube}
	\caption{}\label{fig:seed-0-cube-cpu}
\end{figure}

\begin{figure}[!htbp]
	\gpuplot{seed-0-cube}
	\caption{}\label{fig:seed-0-cube-gpu}
\end{figure}

\begin{figure}[!htbp]
	\memplot{seed-0-cube-single-mem.csv}
	\memplot{seed-0-cube-multi-mem.csv}
	\caption{}\label{fig:seed-0-cube-mem}
\end{figure} 




\begin{figure}[!htbp]
	\fpsplot{seed-0-static}
	\caption{}\label{fig:seed-0-static-fps}
\end{figure}

\begin{figure}[!htbp]
	\cpuplot{seed-0-static}
	\caption{}\label{fig:seed-0-static-cpu}
\end{figure}

\begin{figure}[!htbp]
	\gpuplot{seed-0-static}
	\caption{}\label{fig:seed-0-static-gpu}
\end{figure}

\begin{figure}[!htbp]
	\memplot{seed-0-static-single-mem.csv}
	\memplot{seed-0-static-multi-mem.csv}
	\caption{}\label{fig:seed-0-static-mem}
\end{figure} 



\begin{figure}[!htbp]
	\fpsplot{seed-0-rotate}
	\caption{}\label{fig:seed-0-rotate-fps}
\end{figure}

\begin{figure}[!htbp]
	\cpuplot{seed-0-rotate}
	\caption{}\label{fig:seed-0-rotate-cpu}
\end{figure}

\begin{figure}[!htbp]
	\gpuplot{seed-0-rotate}
	\caption{}\label{fig:seed-0-rotate-gpu}
\end{figure}

\begin{figure}[!htbp]
	\memplot{seed-0-rotate-single-mem.csv}
	\memplot{seed-0-rotate-multi-mem.csv}
	\caption{}\label{fig:seed-0-rotate-mem}
\end{figure} 






\begin{figure}[!htbp]
	\fpsplot{seed-0-walk}
	\caption{}\label{fig:seed-0-walk-fps}
\end{figure}

\begin{figure}[!htbp]
	\cpuplot{seed-0-walk}
	\caption{}\label{fig:seed-0-walk-cpu}
\end{figure}

\begin{figure}[!htbp]
	\gpuplot{seed-0-walk}
	\caption{}\label{fig:seed-0-walk-gpu}
\end{figure}

\begin{figure}[!htbp]
	\memplot{seed-0-walk-single-mem.csv}
	\memplot{seed-0-walk-multi-mem.csv}
	\caption{}\label{fig:seed-0-walk-mem}
\end{figure} 




\begin{figure}[!htbp]
	\fpsplot{seed-3-walk}
	\caption{}\label{fig:seed-3-walk-fps}
\end{figure}

\begin{figure}[!htbp]
	\cpuplot{seed-3-walk}
	\caption{}\label{fig:seed-3-walk-cpu}
\end{figure}

\begin{figure}[!htbp]
	\gpuplot{seed-3-walk}
	\caption{}\label{fig:seed-3-walk-gpu}
\end{figure}

\begin{figure}[!htbp]
	\memplot{seed-3-walk-single-mem.csv}
	\memplot{seed-3-walk-multi-mem.csv}
	\caption{}\label{fig:seed-3-walk-mem}
\end{figure} 





\begin{figure}[!htbp]
	\fpsplot{seed-10-walk}
	\caption{}\label{fig:seed-10-walk-fps}
\end{figure}

\begin{figure}[!htbp]
	\cpuplot{seed-10-walk}
	\caption{}\label{fig:seed-10-walk-cpu}
\end{figure}

\begin{figure}[!htbp]
	\gpuplot{seed-10-walk}
	\caption{}\label{fig:seed-10-walk-gpu}
\end{figure}

\begin{figure}[!htbp]
	\memplot{seed-10-walk-single-mem.csv}
	\memplot{seed-10-walk-multi-mem.csv}
	\caption{}\label{fig:seed-10-walk-mem}
\end{figure} 







