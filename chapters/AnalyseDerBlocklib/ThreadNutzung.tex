Bereits vor dieser Arbeit werden in der Blocklib Threads genutzt, um nebenläufige Anweisungen zu parallelisieren. Darunter fallen insbesondere Hintergrundaufgaben, wie das Erstellen von Chunks, und das Ausführen zeitlich gesteuerter Abläufe, wie die Updates der Flüsse von Flüssigkeiten. Insgesamt gibt es zu Beginn der Arbeit sechs Klassen, die Threads erzeugen und nutzen. Eine Auflistung der Klassen und deren Verwendung von Threads ist in Tabelle~\ref{tab:concTasksBlocklib} zu finden.

\begin{table}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabularx}{\textwidth}{lX}
		\toprule
		Klasse & Bestehende Nutzung von Nebenläufigkeit \\
		\midrule
		\class{ChunkStorage} & Executors werden genutzt, um die Generierung von Chunks und das Meshing von Chunks auszulagern.\\
		\class{EventManager} & Eventhandling wird in Threads ausgelagert, um Deadlocks zu verhindern, wenn die benachrichtigten Beobachter versuchen, auf die selben kritischen Bereiche zuzugreifen. \\
		\class{ConnectionInfo} & Im Server wird ein wiederkehrender Task gestartet, um Ping Nachrichten an die Clients zu senden.\\
		\class{NioClientNetworkLayer} & Ein Thread, der im Hintergrund mit dem Server kommuniziert, wird gestartet.\\
		\class{NioServerNetworkLayer} & Ein Thread, der im Hintergrund mit den Clients kommuniziert, wird gestartet.\\
		\class{Fluid} & Ein Thread wird gestartet, der den Zustand der Flüssigkeit berechnet.\\
		\bottomrule
	\end{tabularx}
	\caption{Nebenläufige Anweisungen in der Blocklib}\label{tab:concTasksBlocklib}
\end{table}

Es gibt keine Zentrale Stelle an der die Erstellung von Threads verwaltet wird. Jede Klasse kümmert sich selbst darum Threads zu erzeugen und zu beenden. Dadurch ist die Anzahl der genutzen Threads nicht leicht zu überblicken. Dadurch lässt sich zum einen schwierig sicherstellen, dass die Anzahl der genutzten Threads die Anzahl der Prozessoren nicht überschreitet, was zu unnötigen Kontextwechseln führt und somit die Performance verschlechtert, zum anderen können die bestehenden Threads möglicherweise nicht voll ausgelastet werden, da nur einzelne Klassen auf diese Zugriff haben.