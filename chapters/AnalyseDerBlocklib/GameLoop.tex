Ein nahezu universelles Designelement von Spielen ist die sogenannte \emph{Game Loop}~\cite[S.~161~ff.]{Nystrom2015}. Sie ist für die Aktualisierung des Spiels zuständig und umfasst typischerweise die Aufgaben 
\begin{itemize}
  \item Berechnung des neuen Spielzustands
  \item (grafische) Ausgabe
  \item Verarbeitung der Eingaben
\end{itemize}
Die Blocklib besitzt ebenfalls eine Game Loop und führt die beschriebenen Aufgaben in der obigen Reihenfolge sequenziell aus. Eigentlich gibt es sogar zwei Game Loops, eine für die Ausführung als Server (ohne graphische Ausgabe) und eine für einen Client oder Einzelspieler. Die Game Loop der Einzelspieler-Blocklib sieht vereinfacht wie folgt aus:
\begin{lstlisting}
while(!shutdown){
	//...
	update(delta); // Berechnung des neuen Spielzustands
	//...
	render(); // grafische Ausgabe
	//...
	window.update(); // Verarbeitung der Eingaben
}
\end{lstlisting}

Die Methode \code{update(delta)} ruft ihrerseits die \code{update(delta)} Methoden der einzelnen Simulationssysteme auf.
\begin{lstlisting}
private void update(float delta) {
	//...
	Context con = Context.getInstance();
	//...
	con.getChunkManager().update(delta);
	con.getEffectManager().update(delta);
	//...
	con.getAudioManager().update();
	con.getMainScheduler().update(delta);
	con.getEntityManager().update(delta);
	con.getFluidManager().update(delta);
	//...
}
\end{lstlisting}
Bei der Berechnung des neuen Spielzustands gibt es in der Blocklib kein zentrales System, das den Zustand des letzten Loopdurchlaufs vorhält. Somit ist es möglich, dass das Verhalten der Blocklib von der Reihenfolge der \code{update(...)} abhängt. Das lässt sich einfach mit einem Beispiel veranschaulichen. 

Man nehme an, dass der \class{EntityManager} prüft, welche Chunks geladen sind, um zu ermitteln, wo ein neuer Gegner erschaffen werden soll. Der \class{ChunkManager} ist dafür zuständig, abhängig von der aktuellen Kameraposition zu bestimmen, welche Chunks geladen werden. Werden nun ein Chunks entfernt, auf dem der EntityManager einen Gegner erschaffen hat, könnte das zu unvorhergesehenem Verhalten führen, da der \class{EntityManager} erwartet, dass der erschaffene Gegner auf einem existenten Chunk erstellt wurde.

Die (mögliche) Abhängigkeit des Verhaltens von der Reihenfolge der updates, zeigt, dass sich diese Berechnungen nicht einfach parallelisieren lassen, da man den gesamten Simulationscode auf mögliche Race Conditions prüfen müsste.