In dieser Arbeit wurde basierend auf der Analyse der Blocklib eine nebenläufige Architektur entworfen und implementiert. Die Architektur baut auf den Strukturen und Ideen \acf{sot} und Jobsystem auf, die in der Computerspielindustrie für die Entwicklung nebenläufiger Architekturen verwendet werden. Da die Blocklib OpenGL nutzt, sind neben dem Jobsystem-Design notwendigerweise auch Aspekte des \ac{sot} integriert worden. Dadurch ist eine hybride Form der Modelle entstanden.

Der \ac{sot}-Teil der Architektur nutzt einen Render-Thread, um das Rendering nebenläufig zu der Simulation durchzuführen. Zentrale Zwischenspeichersysteme, die aus Double-Buffern bestehen, sorgen dafür, dass Wettkampfbedingungen auf den zu rendernden Objekten vermieden werden. Um die Leistung zu optimieren, werden die Objekte, die zur Zwischenspeicherung genutzt werden, nach Gebrauch wiederverwendet.

Das implementiere Jobsystem erfüllt die ermittelten Anforderungen. Es definiert eine Stelle, an der Threads kontrolliert werden, den \classBlocklibExecutor{}, und eine zugehörige Schnittstelle \classBlocklibExecutorService{}. Das Jobsystem bietet die Möglichkeit, Aufgaben zu definieren, die nebenläufig von Threads abgearbeitet werden. Durch die Dekorierung dieser Aufgaben können über die Schnittstelle \classCompletionStage{} komplexe Aufgaben gelöst werden. Das wird ermöglicht, indem \classCompletionStage{} Methoden bereitstellt, um einzelne Jobs zu einem komplexen Job-Graphen zu komponieren. Des Weiteren ermöglicht das Jobsystem, wiederkehrende Aufgaben zu definieren, die automatisiert zu bestimmten Zeiten nebenläufig ausgeführt werden.

Das Jobsystem ermöglicht eine rudimentäre Definition von Prioritäten für die aufgegebenen Tasks, indem zwei getrennte Thread-Pools genutzt werden. Das System ist so vorbereitet, dass ein verbessertes Prioritätensystem basierend auf einer Prioritäts-Warteschlange einfach zu integrieren ist, da die Schnittstelle \classBlocklibExecutorService{} bereits entsprechend definiert ist und der Aufzählungstyp \classTaskPriority{} bereitgestellt wird.

Ein Großteil der bereits bestehenden Nutzung von Multithreading konnte so geändert werden, dass nun die neue nebenläufige Architektur verwendet wird. Einzig die Netzwerkfunktionalitäten der Blocklib bilden hier eine Ausnahme.

Der Start der Blocklib wird durch die neue Architektur um eine Zeit im einstelligen Sekundenbereich verlangsamt. Verglichen mit der alten Architektur erreicht die neue nebenläufige Architektur eine um durchschnittlich \SI{172}{\percent} höhere Bildwiederholrate und weist damit eine deutlich gestiegene Leistung auf. Dabei nutzt die Blocklib mit der neuen Architektur auch einen größeren Teil der zur Verfügung stehenden Leistung des Testsystems aus. Durchschnittlich wird die \ac{cpu} nun mit \SI{28}{\percent} statt \SI{20}{\percent} im Testsystem um \SI{40}{\percent} stärker ausgelastet als zuvor. Aufgrund der Leistungssteigerung ist zu erwarten, dass die gestiegene Auslastung zu einem großen Teil auf die effizientere Nutzung der Anzahl der Hardware-Threads durch die nebenläufige Ausführung von Simulation und Rendering zurückzuführen ist. Auch und die um \SI{37}{\percent} höhere Auslastung der \ac{gpu} spricht dafür, dass die Leistung der \ac{cpu} effektiver genutzt wird, wodurch mehr Anweisungen an die \ac{gpu} geschickt werden. In den Messungen ist die \ac{cpu} jedoch auch mit der neuen Architektur weiterhin die leistungsbeschränkende Komponente, da die Simulation nach wie vor größtenteils sequentiell ausgeführt wird und einen Hardware-Thread voll auslastet, während andere Hardware-Threads untätig sind. Das lässt sich darüber ermitteln, dass die \ac{gpu} in keinem Szenario voll ausgelastet ist. Da die \ac{cpu} ebenfalls nie zu \SI{100}{\percent} ausgelastet ist, muss die Leistungsbeschränkung in der Auslastung eines Hardware-Threads der \ac{cpu} begründet sein.