\textcite[S.~76]{Seemann2012} definiert die \gls{compositionRoot} (engl. composition root) als (vorzugsweise) genau eine Position in einer Anwendung, an der Module zusammengesetzt werden. Die korrekte Nutzung einer \gls{compositionRoot} impliziert die Nutzung von \gls{dependencyInjection} (engl. dependency injection), der Designarchitektur, in der Module ihre Abhängigkeiten nicht selbst erzeugen, sondern diese Aufgabe an aufrufende Module übertragen. Schlussendlich wird diese Aufgabe bis zur \gls{compositionRoot} weitergegeben, in der alle Abhängigkeiten aufgelöst werden. 


Der Entwurf vieler Module in der Blocklib verfolgt einen anderen Ansatz. Insbesondere die abstrakte Klasse \classContext{} und die von ihr abgeleiteten Klassen entsprechen eher einer Mischung aus \gls{servicelocator} und \gls{singleton}. Ein Klassendiagramm von \classContext{} ist in Abbildung~\ref{fig:diagContext} dargestellt. Die statische Methode \code{getInstance()} weist auf das \gls{singleton} Muster hin. Die Klasse besitzt zwar keine Methode \code{resolve(...)}, wie es bei einem üblichen \gls{servicelocator} der Fall wäre, bietet aber stattdessen konkrete Methoden für die einzelnen Dienste, die es in der Blocklib gibt.

\begin{figure}
  \begin{center}
    \includesvg[]{Context-shortened.svg}
  \end{center}
  \caption[Verkürztes Klassendiagramm der Klasse \classContext{}.]{Verkürztes Klassendiagramm der Klasse \classContext{}. Ein vollständiges Diagramm wird in Anhang~\vref{appendix:context} gezeigt.}\label{fig:diagContext}
\end{figure}

Sowohl das ursprüngliche \gls{singleton} Muster von~\textcite[S.~127~\psqq]{Gamma2016} als auch das \gls{servicelocator} Muster werden inzwischen teils kritisch betrachtet~\cites[S.~103~\psqq]{Nystrom2015}[S.~154~\psqq]{Seemann2012}. Das liegt insbesondere daran, dass es beide Entwurfsmuster ermöglichen, Module über die gesamte Code-Basis hinweg zu koppeln, was es wiederum erschwert Auswirkungen von Änderungen im Code abzuschätzen. Des Weiteren erschwert besonders das \gls{singleton} Muster von \classContext{} in der Blocklib das (Unit-) Testen. Nutzt eine Klasse \classContext{}, so ist es nahezu unmöglich, diese isoliert zu testen, da deren Methodenaufrufe sich durch den \classContext{} über die ganze Code-Basis erstrecken können. Diese  Aufrufe können auch nicht durch \glspl{testdouble} (spezielle Module, die das Verhalten von Komponenten vorspielen, damit die Originale beim Testen nicht benötigt werden) ersetzt werden, weil \classContext{} keine Möglichkeit bietet die bereitgestellten Dienste zu ersetzen. Außerdem kann im Test nicht festgestellt werden, welche Methoden überhaupt ersetzt werden müssten, da die Abhängigkeiten einer Klasse versteckt sind. Ruft eine Methode beispielsweise intern \code{Context.getInstance().getWorldInteraction()} auf, so ist das von außen nicht zu erkennen.

\subsubsection{Vorteile einer \glsentrytext{compositionRoot}}

Die Nutzung eines \gls{singleton} und \gls{servicelocator} ist zwar anfangs sehr angenehm, da jedes Modul nur einen Methodenaufruf entfernt ist, sie bringt aber auch die gleichen Probleme wie globale Variablen mit sich. Anders verhält es sich bei der Nutzung von \gls{dependencyInjection} über Konstruktoren und einer \gls{compositionRoot}. Im Folgenden werden einige ihrer Vorteile erläutert.

\paragraph{Erkennung von Abhängigkeiten}Abhängigkeiten werden sichtbar, wenn die Klasse einen Konstruktor besitzt, der eine Instanz von \classWorldInteraction{} erwartet. Dann ist die Abhängigkeit offensichtlich. Es kann also einfach abgeschätzt werden, welche Änderungen Einfluss auf ein bestimmtes Modul haben. Zudem ist klar, welche Bereiche beeinflusst werden können, wenn Methoden der Klasse aufgerufen werden. Es sind nur Module betroffen, zu denen sie auch eine Referenz besitzt.

\paragraph{Vermeidung versehentlicher Abhängigkeiten} Außerdem wird die Gefahr verhindert, dass versehentlich neue Abhängigkeiten aufgebaut werden, denn diese müssen explizit im Konstruktor angegeben werden. Wird ein \gls{servicelocator} genutzt, genügt ein einfacher Methodenaufruf.

\paragraph{Vereinfachtes Testen} Durch die Angabe in dem Konstruktor ist ersichtlich, welche Abhängigkeiten bestehen. Der Austausch der Abhängigkeiten durch ein \gls{testdouble} ist trivial, da das Ersatz-Objekt der Klasse bei dem Aufruf des Konstruktors übergeben werden kann. Das bietet einen Ansatz zur Lösung einer der Aufgaben in der Blocklib -- der Etablierung einer automatisierten Testabdeckung. Aktuell muss bei vielen Tests die gesamte Blocklib gestartet werden, sodass die Tests zu lange dauern, um sie in regelmäßigen Intervallen durchführen kann.

\textcite[S.~15~\psqq]{Seemann2012} beschreibt noch einige weitere Vorteile der Nutzung von \gls{dependencyInjection}, darunter Erweiterbarkeit und die Möglichkeit leichter parallel Code zu entwickeln. Ein besonders wichtiger Punkt für die Blocklib ist zudem die verbesserte Wartbarkeit, da der Durchsatz an Entwicklerinnen und Entwicklern, die an der Blocklib arbeiten, sehr hoch ist.

\subsubsection{Mögliche Probleme bei der Umstellung}
Die genannten Vorteile machen die breite Etablierung der Nutzung von \gls{dependencyInjection} in Verbindung mit einer zentralen \gls{compositionRoot} erstrebenswert. Das Wort \enquote{breit} lässt allerdings bereits vermuten, dass diese Etablierung sehr viele Änderungen in der Blocklib hervorrufen wird. Im Folgenden wird nun beschrieben, welche Probleme dabei in der Blocklib auftreten können.

\paragraph{Position der \glsentrytext{compositionRoot}}
Typischerweise soll die Komposition des Objektgraphen, also die Zusammensetzung der Module in der \gls{compositionRoot}, so nah wie möglich am Einstiegspunkt des \glsuseri{Programm} liegen~\cites[S.~232~\psqq]{Martin17}[S.~76~\psq]{Seemann2012}. Das liegt daran, dass man dadurch die Entscheidung, wie die Komposition auszusehen hat, und zugleich konkrete Abhängigkeiten möglichst lang herauszögern kann. Man erreicht so also eine möglichst lose Kopplung der einzelnen Module des \glsuseri{Programm}.

Die Blocklib stellt nun einen besonderen Fall dar, da sie eigentlich eine Bibliothek darstellt. Der Programmeinstiegspunkt liegt also an einer anderen Stelle, nämlich in dem \classBlockLibProgram{}, das ausgeführt wird. Platziert man die \gls{compositionRoot} dort, besitzt jedes \gls{Programm} völlige Freiheit bei der Komposition der Blocklib. Allerdings ist dies dem Ziel abträglich, die Blocklib möglichst einfach nutzen zu können, zumal die Komposition in den meisten Fällen identisch ist. Einen Sonderfall stellt hier die Nutzung der Blocklib in der Multiplayer-Version dar, da hier beispielsweise für die Klassen \classWorldInteraction{} und \classContext{} spezielle Unterklassen vorhanden sind, die je nach Blocklib-Version verwendet werden. Alternativ kann man die Klasse \classGame{} als Einstiegspunkt betrachten, da hier bereits einige bibliotheksinterne Module komponiert werden und sie die Klasse ist, die in dem \classBlockLibProgram{} instanziiert wird. Sie stellt also den Einstiegspunkt für die Bibliothek dar. Wird die \gls{compositionRoot} allerdings hier platziert, verliert das \classBlockLibProgram{} die Möglichkeit der freien Konfiguration.

Wird die Blocklib in der Multiplayer-Version genutzt, entsteht ein weiteres Problem, da dem gestarteten Spring-Server keine Parameter übergeben werden. Es gibt nur einen Standardkonstruktor. Es muss also evaluiert werden, ob und wie Abhängigkeiten an den Server übergeben werden können. Ansonsten ist er von der \gls{compositionRoot} ausgeschlossen.

\paragraph{Aufwand der Umstellung}
Wie bereits erwähnt, wird die Etablierung einer \gls{compositionRoot} in der Blocklib sehr viele Änderungen hervorrufen, da beinahe jedes Modul über den \classContext{} verfügbar ist. Es lässt sich allerdings nicht abschätzen, wie hoch der Aufwand für eine Umstellung tatsächlich ist. Es gibt möglicherweise Stellen, an denen das Design eines Moduls davon abhängt, dass es einen \classContext{} gibt, sodass das Modul komplett umstrukturiert werden muss. Andererseits kann es auch sein, dass die Umstellung nur die Erzeugung von geeigneten Konstruktoren erfordert und sehr simpel ist. Aufgrund der durch den \classContext{} versteckten Abhängigkeiten lässt sich das im Voraus nicht ermitteln, sondern wird sich erst bei der Durchführung zeigen.
