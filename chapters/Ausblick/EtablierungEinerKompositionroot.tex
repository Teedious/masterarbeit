\begin{figure}
  \begin{center}
    \includesvg[]{Context-shortened.svg}
  \end{center}
  \caption{A}\label{fig:diagContext}
\end{figure}
\textcite[S.~76]{Seemann2012} definiert die \emph{Composition Root} als (vorzugsweise) genau eine Position in einer Anwendung an der Module zusammengesetzt werden. Die korrekte Nutzung einer Composition Root impliziert die weite Verbreitung von \emph{Dependency Injection}, der Designarchitektur, in der Module ihre Abhängigkeiten nicht selbst erzeugen, sondern diese Aufgabe an aufrufende Module übertragen. Schlussendlich wird diese Aufgabe bis zur Composition Root weitergegeben, wo alle Abhängigkeiten aufgelöst werden. 


Das Design vieler Module in der Blocklib verfolgt häufig einen anderen Ansatz. Insbesondere Die abstrakte Klasse \class{Context} und die von ihr erbenden Klassen entsprechen eher einer Mischung aus \emph{Service Locator}~\cite[S.~301~ff.]{Nystrom2015} und \emph{Singleton}~\cite[S.~103~ff.]{Nystrom2015}. Ein Klassendiagramm von \class{Context} ist in Abbildung~\ref{fig:diagContext} dargestellt. Die statische Methode \code{getInstance()} weißt auf das Singleton Pattern hin. Die Klasse besitzt zwar keine Methode \code{resolve(...)}, wie es bei einem üblichen Service Locator der Fall wäre, bietet aber stattdessen konkrete Methoden für die einzelnen Dienste, die es in der Blocklib gibt.

Sowohl das ursprüngliche Singleton Pattern von~\textcite[S.~127~ff.]{Gamma2016}, als auch das Service Locator Pattern werden inzwischen teils kritisch betrachtet~\cite[S.~103~ff.]{Nystrom2015}\cite[S.~154~ff.]{Seemann2012}. Das liegt insbesondere daran, dass es beide Patterns ermöglichen, Module über die gesamte Code Basis hinweg zu koppeln, was es wiederum erschwert Auswirkungen von Änderungen im Code abzuschätzen. Des Weiteren erschwert besonders das Singleton Pattern von \class{Context} in der Blocklib das (Unit-) Testen. Nutzt eine Klasse \class{Context}, so ist es nahezu unmöglich, diese isoliert zu testen, da deren Methodenaufrufe sich durch den \class{Context} über die ganze Code Bases erstrecken können. Diese  Aufrufe können auch nicht durch \emph{Test Doubles} (also spezielle Module, die das Verhalten von Komponenten vorspielen, damit die Originale beim Testen nicht benötigt werden) ersetzt werden, weil \class{Context} keine Möglichkeit bietet die bereitgestellten Dienste zu ersetzen. Außerdem kann im Test nicht festgestellt werden, welche Methoden überhaupt ersetzt werden müssten, da die Abhängigkeiten einer Klasse versteckt sind. Ruft eine Methode beispielsweise intern \code{Context.getInstance().getWorldInteraction()} auf, so ist das von außen nicht zu erkennen.

\subsection{Vorteile einer Composition Root}

Die Nutzung eines Singleton und Service Locator ist zwar anfangs sehr angenehm, da jedes Modul nur einen Methodenaufruf entfernt ist, sie bringt aber auch die gleichen Probleme mit sich wie globale Variablen. Anders verhält es sich bei der Nutzung von Dependency Injection über Konstruktoren und einer Composition Root. Im folgenden sind kurz einige ihrer Vorteile erläutert.

\paragraph{Abhängigkeiten werden sichtbar} wenn die Klasse einen Konstruktor besitzt, der eine Instanz von \class{WorldInteraction} erwartet. Dann ist die Äbhängigkeit offensichtlich. Es kann also einfach abgeschätzt werden, welche Änderungen Einfluss auf ein bestimmtes Modul haben. Zudem ist klar welche Bereiche beeinflusst werden können, wenn Methoden der Klasse aufgerufen werden, nämlich nur diejenigen zu denen sie auch eine Referenz besitzt.

\paragraph{Keine versehentlichen Abhängigkeiten} Außerdem wird die Gefahr verhindert aus Versehen, neue Abhängikeiten aufzubauen, denn diese müssen explizit im Konstruktor angegeben werden. Bei einem Service Locator reicht ein einfacher Methodenaufruf.

\paragraph{Das Testen wird vereinfacht} Es ist klar, dass die Klasse \class{WorldInteraction} genutzt wird, sie wird ja schließlich dem Konstruktor übergeben. Der Austausch von \class{WorldInteraction} durch ein Test Double ist trivial, da deses einfach beim Aufruf des Konstruktors der Klasse übergeben werden kann. Dadurch lässt sich einfach eines der großen Probleme der Blocklib angehen -- eine fehlende automatisierte Testabdeckung. Aktuell muss bei den meisten Tests die gesamte Blocklib gestartet werden, sodass die Tests zu lange dauern, als dass man sie in häufigen Intervallen durchführen kann.

\textcite[S.~15~ff.]{Seemann2012} beschreibt noch einige weitere Vorteile der Nutzung von Dependency Injection, darunter Erweiterbarkeit und die Möglichkeit leichter parallel Code zu entwickeln. Ein besonders wichtiger Punkt für die Blocklib ist zudem die verbesserte Wartbarkeit, da der Durchsatz an Entwicklerinnen und Entwicklern, die an der Blocklib arbeiten, sehr hoch ist.

\subsection{Mögliche Probleme bei der Umstellung}

Somit kann man davon ausgehen, dass die breite Etablierung der Nutzung von Dependency Injection in Verbindung mit einer zentralen Composition Root erstrebenswert ist. Das Wort \enquote{breit} lässt allerdings bereits vermuten, dass diese Etablierung sehr viele Änderungen in der Blocklib hervorrufen wird. Im Folgenden wird nun beschrieben, welche potentiellen Probleme dabei in der Blocklib zu bewältigen sind.

\paragraph{Wo ist die Composition Root?}
Typischerweise soll die Komposition des Objektgraphen, also die Zusammensetzung der Module in der Composition Root, so nah wie möglich am Einstiegspunkt des Programms liegen~\cite[S.~232~ff.]{Martin17}\cite[S.~76~f.]{Seemann2012}. Das liegt daran, dass man dadurch die Entscheidung, wie die Komposition auszusehen hat und zugleich konkrete Abhängigkeiten, so lange wie möglich herauszögern kann. Man erreicht so also eine möglichst lose Kopplung der einelnen Module des Programms.

Die Blocklib stellt nun einen besonderen Fall dar, da sie eigentlich nur eine Bibliothek darstellt. Der Programmeinstiegspunkt liegt also an einer anderen Stelle, nämlich in dem \class{BlockLibProgram}, das ausgeführt wird. Platziert man die Composition Root dort besitzt jedes Programm völlige Freiheit, bei der Komposition der Blocklib. Allerdings ist dies dem Ziel abträglich, die Blocklib möglichst einfach nutzen zu können, zumal in den allermeisten Fällen die Komposition identisch sein wird. Einen Sonderfall stellt hier die Nutzung der Blocklib in der Multiplayer-Version dar, da hier tatsächlich beispielsweise für die Klassen \class{WorldInteraction} und \class{Context} spezielle Unterklassen vorhanden sind, die je nach Blocklib-Version verwendet werden. Alternativ kann man die Klasse \class{Game} als Einstiegspunkt betrachten, da hier bereit einige bibliotheksinterne Module komponiert werden und sie die Klasse ist, die in dem \class{BlockLibProgram} instanziiert wird. Sie stellt also den Einstiegspunkt für die Bibliothek dar. Wird die Composition Root allerdings hier plaziert, verliert das \class{BlockLibProgram} allerdings die Möglichkeit der freien Konfiguration.

Wird die Blocklib in der Multiplayer-Version genutzt, entsteht ein weiteres Problem, da der gestartete Spring-Server keine Parameter übergeben bekommt. Es gibt nur einen Standardkonstruktor. Es muss also evaluiert werden, ob und wie Abhängigkeiten an den Server übergeben werden können. Ansonsten ist er von der Composition Root ausgeschlossen.

\paragraph{Aufwand der Umstellung ist nicht abzuschätzen}
Wie bereits erwähnt, wird die Etablierung einer Composition Root in der Blocklib sehr viele Änderungen hervorrufen, da beinahe jedes Modul über den \class{Context} verfügbar ist. Es lässt sich allerdings nicht abschätzen, wie hoch der Aufwand für eine Umstellung tatsächlich ist. Es gibt vielleicht Stellen, an denen das Design eines Moduls davon abhängt, dass es einen \class{Context} gibt, sodass das Modul komplett umstrukturiert werden muss. Andererseits kann es auch sein, dass die Umstellung nur die Erzeugung von geeigneten Konstruktoren erfordert und sehr simpel ist. Aufgrund der durch den \class{Context} versteckten Abhängigkeiten lässt sich das im Voraus nicht ermitteln sondern wird sich erst bei der Durchführung zeigen.
