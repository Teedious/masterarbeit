Da es sich bei der Blocklib um ein großes bereits bestehendes System handelt \todo{Zeilenzahl angeben}, ist es unrealistisch, in kurzer Zeit das gesamte Programm so umzustrukturieren, dass es vollständig eine Jobarchitektur nutzt. Diese Umstrukturierung erfordert tiefes Verständnis für jedes zu Ändernde System. Zudem müssen viele Bereiche grundlegend geändert werden, um die Abhängigkeiten der Systeme zu veringern beziehungsweise deren Vorhandensein auszuschließen.

Die Blocklib enthält beispielsweise eine Klasse \class{Context}, die als eine Art Singletonimplementierung eines Service Locators~\cite[S.~301~ff.]{Nystrom2015} dient. Da Singletons ähnlich wie globale Variablen von überall aufgerufen werden können, wird der Code dadurch potenziell schwieriger nachvollziehbar~\cite[S.~108]{Nystrom2015}. Dadurch und durch die ebenfalls resultierende Kopplung unterschiedlicher Komponenten würden bei einer naiven Umsetzung der Jobarchitektur unvorhersehbar Wettkampfbedingungen auftreten.
Man erinnere sich, dass Wettkampfbedingungen auftreten wenn nebenläufige Aktivitäten auf die selben Ressourcen zugreifen. Durch den \class{Context} ist es nun schwierig, einen Überblick zu haben von wo aus auf welche Ressourcen zugegriffen wird. Die Wahrscheinlichkeit, dass also Zugriffe existieren, die zu Wettkampfbedingungen führen ist also sehr hoch, solange dabei nicht sorgsam vorgegangen wird.

Da der Performancegewinn, in Form von \ac{fps}, bei der Nutzung eines Renderthreads als hoch zu erwarten ist, soll dieser in die Blocklib integriert werden. Um die Anforderungen von Kapitel~\ref{sec:anforderungen} zu Erfüllen, ein Jobsystem implementiert werden, das aber nur an ausgewählten Stellen mit der Blocklib konsolidiert wird und ansonsten für die zukünftige Nutzung bereitsteht.

\subsection{Design des Renderthreads}
Der Renderthread kann einerseits als Teil des Jobsystems designed werden, andererseits gibt es die Möglichkeit den Renderthread von diesem zu trennen. Ist der Renderthread Teil des Jobsystems, kann dieser voll zur Bearbeitung von Jobs mitgenutzt werden. Da üblicherweise die Anzahl der Threads der Anzahl der Prozessorkerne entspricht, kann man so automatisch immer die Leistung aller Prozessorkerne nutzen. Trennt man den Thread dagegen ab, entsteht die Problematik zu entscheiden, wann welche Anzahl von Threads genutzt wird, um möglichst alle Kerne zu nutzen, aber gleichzeitig zu verhindern, dass sich die Threads in der Ausführung gegenseitig behindern. Andererseits gestaltet sich die Implementierung eines getrennten Renderthreads als deutlich einfacher und intuitiver~\cite{Tatarchuk2014}, im Gegensatz zur Jobsystemintegration.

Da das Jobsystem keine vollständig Integration in die Blocklib erfährt und das Rendering in etwa \SI{50}{\percent}\todo{messen} der Framezeit benötigt, bietet es sich an, den Renderthread zu separieren. Der mögliche Performancegewinn durch die Integration in das Jobsystem ist bereits ausgeschlossen, da das Rendering selbst sie gesamte Rechenleistung des Kerns jeden Frame beansprucht. Damit kann auch die Problematik der Anzahl der Threads gelöst werden, indem die Anzahl der Jobthreads um eins veringert wird ohne dadurch Prozessorkerne ohne Arbeit zu verursachen.

Da der Renderthread auf Daten des Spiels zugreift, um die sichtbaren Elemente zu zeichnen, muss sichergestellt werden, dass diese Daten keinen Wettkampfbedingungen unterliegen. In der Spieleentwicklung ist es üblich einen \emph{Spielzustand} (engl. Game State) zu definieren, der während der Simulation in jedem Frame angepasst wird. Der Teil des Zustandes auf den der Renderthread zugreift muss also konstant sein. Während der Simulation wird dieser allerdigs verändert. Einge Möglichkeit, dieses Problem zu beheben, besteht darin einen \emph{Double Buffer}~\cite[S.~143]{Nystrom2015} zu nutzen, um den gesamten Spielzustand zwischenzuspeichern~\cite{Tatarchuk2014}. Die Blocklib ist nicht mit diesem Hintergrund entwickelt worden, weswegen es keine einfache Möglichkeit gibt, den gesamten Spielzustand auf diese Weise zwischenzuspeichern. Die Objekte, die den Spielzustand darstellen sind über die Blocklib hinweg verteilt. 

Um dennoch einen Renderthread nutzen zu können müssen die Objekte identifiziert werden, die für das Rendering benötigt werden. Für diese Objekte muss dann ein geeigneter Double Buffer erzeugt werden, sodass die Daten aus Renderthread-Sicht konstant sind.