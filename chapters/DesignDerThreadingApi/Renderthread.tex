
Die Blocklib nutzt OpenGL als Grafik Schnittstelle. Da OpenGL, wie in Abschnitt~\ref{sec:gamesJobsystem} beschrieben, Multithreading nicht unterstützt, kann das Rendering selbst nicht nebenläufig durchgeführt werden, sondern muss auf einem Renderthread ausgeführt werden.

Der Renderthread kann einerseits als Teil des Jobsystems designt werden, andererseits gibt es die Möglichkeit den Renderthread von diesem zu trennen. Ist der Renderthread Teil des Jobsystems, kann dieser voll zur Bearbeitung von Jobs mitgenutzt werden. Da die Anzahl der Threads des Jobsystems üblicherweise der Anzahl der Hardware-Threads entsprechen soll, lässt sich so automatisch immer die Leistung aller Prozessorkerne nutzen. Trennt man den Thread dagegen ab, entsteht einerseits die Problematik zu entscheiden, wann welche Anzahl von Threads genutzt wird, um möglichst alle Kerne zu nutzen, aber gleichzeitig zu verhindern, dass sich die Threads in der Ausführung gegenseitig behindern. Andererseits gestaltet sich die Implementierung eines getrennten Renderthreads im Vergleich zur Jobsystemintegration als deutlich einfacher und intuitiver~\cite{Tatarchuk2014}, da beispielsweise nicht ermittelt werden muss, wann der Renderthread zur Ausführung von Jobs genutzt werden kann.

Über eine Analyse der Methodenlaufzeiten in der Blocklib ergibt sich, dass das Rendering knapp die Hälfte der Zeit eines Frames benötigt. Der prinzipiell mögliche Performancegewinn durch die Integration in das Jobsystem ist damit vernachlässigbar, da das Rendering selbst meist die gesamte Rechenleistung des Kerns beansprucht. Da das Rendering im sequentialisierten Fall circa \SI{50}{\percent} der Zeit benötigt, entspricht das, sobald Simulation und Rendering in zwei Threads nebenläufig ausgeführt werden, annähernd \SI{100}{\percent}. Wird die Simulation selbst vermehrt nebenläufig durchgeführt, verstärkt sich dieser Effekt, da sich damit die von der Simulation benötigte Zeit weiter verringert. Daher bietet es sich an, den Renderthread zu separieren. Vor diesem Hintergrund lässt sich auch die Anzahl der Threads des Jobsystems bestimmen, obwohl für das Rendering ein \ac{sot} Design genutzt wird. Die Anzahl der Jobthreads wird im Vergleich zu der Anzahl der Hardware-Threads um eins verringert. Aufgrund der vollen Auslastung des Renderthreads führt das nicht zu Hardware-Threads, die keine Arbeit entgegen nehmen können.

Da der Renderthread nebenläufig auf Daten des Spiels zugreift, um die sichtbaren Elemente zu zeichnen, muss sichergestellt werden, dass diese Daten keinen Wettkampfbedingungen unterliegen. In der Spielentwicklung ist es üblich einen \emph{Spielzustand} zu definieren, der während der Simulation in jedem Frame angepasst wird. Der Teil des Zustands auf den der Renderthread nutzt muss also während dieses Zugriffs konstant sein. Durch die Simulation wird dieser allerdings verändert. Eine Möglichkeit, dieses Problem zu beheben, besteht darin einen \emph{Double Buffer}~\cite[S.~143]{Nystrom2015} zu nutzen, um den gesamten Spielzustand zwischenzuspeichern~\cite{Tatarchuk2014}. Die Blocklib ist aber nicht mit diesem Hintergedanken entwickelt worden, weswegen es keine einfache Möglichkeit gibt, den gesamten Spielzustand zwischenzuspeichern. Die Objekte, die den Spielzustand darstellen, sind über die Blocklib hinweg verteilt. Um dennoch einen Renderthread nutzen zu können, müssen die Objekte identifiziert werden, die für das Rendering benötigt werden. Für diese Objekte muss dann ein geeigneter Double Buffer erzeugt werden, sodass die Daten aus Renderthread-Sicht konstant sind.


\begin{figure}
	\centering
	\begin{tikzpicture}[scale=1.1]
		\fill[lightgray]  (0,0) rectangle (11,1);
		\fill[lightgray] (0,-1.5) rectangle (11,-0.5);
		\fill[lightgray]  (0,1.5) rectangle (11,2.5);
		
		\node[anchor=east] at (0,2) {Thread 1};
		\node[anchor=east] at (0,0.5) {Thread 2};
		\node[anchor=east] at (0,-1) {Renderthread};
		
		
		\fill [orange,draw=lightgray] (0.5,1.5) rectangle node[black] {Sim} (1.5,2.5);
		\fill [orange,draw=lightgray] (0.5,0) rectangle node[black] {Sim} (1.5,1);
		\fill [orange,draw=lightgray] (1.5,1.5) rectangle node[black] {Sim} (2.5,2.5);
		\fill [orange,draw=lightgray] (2.5,1.5) rectangle node[black] {Sim} (3.5,2.5);
		\fill [orange,draw=lightgray] (1.5,0) rectangle node[black] {Sim} (2.5,1);
		\fill [orange,draw=lightgray] (3.5,1.5) rectangle node[black] {Sim} (4.5,2.5);
		\fill [orange,draw=lightgray] (2.5,0) rectangle node[black] {Sim} (3.5,1);
		\fill [orange,draw=lightgray] (3.5,0) rectangle node[black] {Sim} (4.5,1);
		
		\fill [orange,draw=lightgray] ($(4.5,0)+(0.5,1.5)$) rectangle node[black] {Sim} ($(4.5,0)+(1.5,2.5)$);
		\fill [orange,draw=lightgray] ($(4.5,0)+(0.5,0)$) rectangle node[black] {Sim} ($(4.5,0)+(1.5,1)$);
		\fill [orange,draw=lightgray] ($(4.5,0)+(1.5,1.5)$) rectangle node[black] {Sim} ($(4.5,0)+(2.5,2.5)$);
		\fill [orange,draw=lightgray] ($(4.5,0)+(2.5,1.5)$) rectangle node[black] {Sim} ($(4.5,0)+(3.5,2.5)$);
		\fill [orange,draw=lightgray] ($(4.5,0)+(1.5,0)$) rectangle node[black] {Sim} ($(4.5,0)+(2.5,1)$);
		\fill [orange,draw=lightgray] ($(4.5,0)+(3.5,1.5)$) rectangle node[black] {Sim} ($(4.5,0)+(4.5,2.5)$);
		\fill [orange,draw=lightgray] ($(4.5,0)+(2.5,0)$) rectangle node[black] {Sim} ($(4.5,0)+(3.5,1)$);
		\fill [orange,draw=lightgray] ($(4.5,0)+(3.5,0)$) rectangle node[black] {Sim} ($(4.5,0)+(4.5,1)$);
	
		\fill [magenta] (0.5,-0.5) rectangle node[black]{Render $n-1$} (4.2,-1.5);
		\fill [magenta] (5,-0.5) rectangle node[black]{Render $n$} (8.7,-1.5);
		
		\node at (2.5,3.5) {Frame $n$};
		\node at (7,3.5) {Frame $n+1$};
		
		\draw  (0.5,3) rectangle (4.5,-2);
		\draw  (5,3) rectangle (9,-2);
	\end{tikzpicture}
	\caption[Darstellung des gewünschten Designs der Multithreading Architektur der Blocklib.]{Darstellung des gewünschten Designs der Multithreading Architektur der Blocklib. Es existiert ein gesonderter Renderthread, der einen großen Teil der Rechenzeit während eines Frames nutzt (magenta). Die Simulation ist in Jobs (orange) aufgeteilt, die auf beliebig viele Threads aufgeteilt werden können. \enquote{Sim} kennzeichnet einen Simulationsjob.}\label{fig:optimalArchitecture}
\end{figure}

Somit ist eine nebenläufige Architektur, wie sie in Abbildung~\vref{fig:optimalArchitecture} dargestellt wird, erstrebenswert. Es gibt einen Renderthread, der die von der Simulation im vorherigen Frame berechneten Objekte zeichnet. Alle anderen verfügbaren Hardware-Threads können in dem Jobsystem für die Simulation genutzt werden.