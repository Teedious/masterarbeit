Da ein Jobsystem implementiert wird, bietet sich der \code{main}-Thread als Renderthread an. Alle anderen Rechenprozesse werden über das Jobsystem auf anderen Threads ausgeführt. Bei der Implementierung der für einen Renderthread nötigen Funktionalität müssen in der Blocklib viele verschiedene Klassen angepasst werden. Der Übersichtlichkeit halber werden die Anpassungen in Bereiche eingeteilt. 

In Abschnitt~\ref{sec:loader} wird beschrieben, wie das Laden von Daten auf die \ac{gpu} geändert werden muss, nachdem dieser Vorgang aus Sicht der Simulation nun wegen der Nebenläufigkeit des Renderthreads asynchron ist. Danach erläutert Abschnitt~\ref{sec:statelessRendering} den Wechsel von einer Renderarchitektur,die sich zu zeichnende Elemente merkt, zu einer zustandslosen Architektur. Abschnitt~\ref{sec:saveRenderState} beschreibt, wie darauf aufbauend der Zustand der zu zeichnenden Elemente unter Verwendung von Double-Buffers zwischengespeichert wird, damit er während des Renderings unverändert bleibt. In Abschnitt~\ref{sec:adjustGameLoop} wird schließlich beschrieben, wie der Aufbau der Game-Loop an die neue Architektur angepasst wird.

\subsubsection{Laden von Daten auf die \glsentryuseri{gpu}}\label{sec:loader}
In der Blocklib werden häufig Daten an die \ac{gpu} übergeben. Beispielsweise muss bei der Generierung eines Chunks ein Gitternetz konstruiert werden, das die Form des Terrains im Chunk beschreibt, und dann an die \ac{gpu} gesendet werden. Dafür wird die OpenGL API genutzt. Da alle Aufrufe an OpenGL auf einem Thread ausgeführt werden müssen, ist dafür zu sorgen, dass Anweisungen zwischengespeichert werden, die mit der \ac{gpu} interagieren, aber zum Beispiel durch die Chunkgenerierung angestoßen werden. Dann können die zwischengespeicherten Anweisungen vom Renderthread ausgelesen und ausgeführt werden. 

Um Anweisungen zum Laden von Daten auf die \ac{gpu} zwischenzuspeichern, muss die dafür zuständige Klasse \class{Loader} angepasst werden. Die Klasse wird um eine Warteschlange erweitert, die Objekte vom Typ \class{Runnable} enthält. Anstatt die Ladeanweisungen direkt auszuführen, werden sie als Tasks der Warteschlange übergeben und dort als \class{Runnable}-Objekte gespeichert. Die Warteschlange nutzt intern die von Java bereitgestellte Klasse \class{ConcurrentLinkedQueue}. Die Warteschlange bietet damit nicht-blockierende Synchronisierung, wodurch mehrere Threads gleichzeitig Elemente der Warteschlange hinzufügen können, ohne dass das zu Wettkampfbedingungen führen kann. In der Game-Loop der Blocklib wird diese Warteschlange zu Beginn vom Renderthread abgearbeitet, damit danach sowohl die Simulation als auch der Renderer darauf Zugriff haben. 

\begin{figure}
	\centering
	\includesvg[width=.85\textwidth]{Loader.svg}
	\caption{Klassendiagramm der wichtigsten Klassen, die am Laden und Entfernen von Daten auf und von der \ac{gpu} beteiligt sind. Zum Laden wird der Loader aufgerufen, dieser erstellt einen Task, der eine der drei Transmitter-Klassen aufruft. Die so erstellten Tasks werden an \class{DoubleBufferedAsyncQueue} übergeben, die ein \class{CompletableFuture}-Objekt zurückgibt.}\label{fig:loaderDiagram}
\end{figure}
Ein Diagramm der wichtigsten beteiligten Klassen ist in Abbildung~\vref{fig:loaderDiagram} gezeigt. Im Klassendiagramm sind die drei Klassen \class{VAOTransmitter}, \class{TextureTransmitter} und \class{DataTransmitter} abgebildet. Die Klasse \class{Loader} erzeugt Tasks, die dann Methoden dieser Klassen aufrufen, je nachdem, welche Art von Daten an die \ac{gpu} übertragen oder von dor gelöscht werden soll. Die Klasse \class{VAOTransmitter} ermöglicht den Umgang mit sogenannten \acp{vao}. Das ist eine Datenstruktur, die alle relevanten Informationen zur Darstellung eines Modells enthält, beispielsweise eines Chunks oder des Spielercharakters. Mit der Klasse \class{TextureTransmitter} lassen sich Texturen übertragen, die beispielsweise das Aussehen von Blöcken definieren. Der \class{DataTransmitter} wird genutzt, um die Daten an die \ac{gpu} zu senden, die für die Berechnung von Niederschlag, wie Regen und Schnee, benötigt werden.

Die Klassen \class{RawModel} und \class{ModelTexture}, die Informationen der \acp{vao} und Texturen speichern, implementieren das neu hinzugefügte Interface \class{AsyncGraphicsObject}, das die Methoden 	\code{setLoaded(int id): void}, 
\code{setUnloaded(): void} und 
\code{isLoaded(): boolean} bereitstellt. Damit kann überprüft werden, ob die aud die \ac{gpu} geladen sind oder nicht. Die Renderer-Klassen, auf die in Abschnitt~\ref{sec:saveRenderState} genauer eingegangen wird, prüfen damit, ob nicht geladene Objekte gerendert werden sollen, und geben gegebenenfalls einen Fehler aus.

Die Abarbeitung aller Ladevorgänge der Klasse \class{Loader} muss synchronisiert sein, da die Simulation sonst beispielsweise versuchen könnte ein Objekt rendern zu lassen, das noch nicht geladen wurde. Nachdem die Daten eines Objekts auf die \ac{gpu} geladen worden sind, kann das Objekt dann gerendert werden.

\begin{figure}
	\centering
	\includegraphics[height=4.5cm]{player.png}
	\caption{Screenshot der Spielerfigur, die in diesem Kapitel als Beispiel für die Implementierung des Renderthreads verwendet wird.}\label{fig:player}
\end{figure}

Die Klasse \class{Player} ist beispielsweise für die Simulation des Spielercharakters zuständig. Zur Veranschaulichung ist ein Screenshot der Spielerfigur in Abbildung~\vref{fig:player} dargestellt. Wird ein neuer Spielercharakter erstellt, so ruft die Klasse \class{Player} die Methode \code(init(): void) auf, wodurch über verschiedene Methodenaufrufe zum Schluss auch \code{Loader.loadToVAO(...)} aufgerufen wird. Der \class{Loader} erzeugt einen Task, mit Daten des \class{Player}-Modells und fügt diesen Task in die Warteschlange ein. Im Frame danach wird die Warteschlange abgearbeitet und das Modell auf die \ac{gpu} geladen. Damit steht das zu ladende Spielercharakter-Modell ab diesem Frame zur Verfügung und kann genutzt werden, um den Charakter zu zeichnen. Wie der Vorgang des Zeichnens aufgebaut ist, wird in den folgenden Abschnitten erklärt. Dort wird dieses Beispiel fortgeführt.

\subsubsection{Zustandsloses Rendering}\label{sec:statelessRendering}
In der Blocklib implementieren alle zu zeichnenden Elemente das Interface \class{Renderable}. Dieses definiert die Funktionalität, die zum Zeichnen eines Elements notwendig ist, sowie die Methoden \code{show()} und \code{hide()}. Das Rendersystem ist so aufgebaut, dass ein Element nach einem Aufruf von \code{show()} solange gezeichnet wird, bis \code{hide()} aufgerufen wird. Dies wird erreicht, indem eine Datenstruktur im \class{MasterRenderer} alle Renderables speichert. Diese zustandsbehaftete Zeichenmethode birgt Vor- und Nachteile.

\begin{itemize}
	\item[$+$] Da \code{show()} nur einmal aufgerufen werden muss, können auch Systeme ohne Updatemethode das Zeichnen von Elementen veranlassen.
	\item[$+$] Da die Elemente gespeichert sind, müssen sie nicht jedes Mal neu hinzugefügt werden. Das verringert den Rechenbedarf.
	\item[$-$] Werden Renderables häufig ausgetauscht, müssen die alten Elemente jedes Mal entfernt werden.
	\item[$-$] Da die Einführung eines parallelen Renderthreads ansonsten zu Race Conditions führen würde, muss diese Datenstruktur aus Sicht des Renderthreads während des Zeichnens unverändert sein. Wie beschrieben, wird dazu ein Double Buffer eingesetzt. Bei einem zustandsbehafteten Double Buffer müssen beim Swap die Elemente des einen Buffers in den anderen Buffer kopiert werden. Das erfordert Zeit, die nicht parallelisiert werden kann, da das Wechseln des Buffers synchronisiert sein muss.
	\item[$-$] Die Existenz von paarweise aufzurufenden Funktionen birgt die Gefahr, dass der zweite Aufruf vergessen wird. Wie bei \code{malloc()} und \code{free()} in C entsteht durch einen fehlenden Aufruf von \code{hide()} ein Speicherleck. Zudem wird dann die Anzahl der zu zeichnenden Elemente immer größer und der Rendervorgang wird verlangsamt. Des Weiteren werden möglicherweise Renderables gezeichnet, die nicht gezeichnet werden sollen.
\end{itemize}

Um den Zeichenaufwand zu verringern, implementiert die Klasse \class{ChunkManager} das sogenannte \emph{Frustum Culling}. Es wird berechnet, welche Chunks sich im Sichtfeld der Kamera befinden. Nur diese Chunks sollen gezeichnet werden. Dazu entfernt der ChunkManager jeden Frame alle Chunks mittels \code{hide()} aus der Datenstruktur der zu zeichnenden Elemente und fügt nur die als sichtbar ermittelten Chunks wieder ein. Die Chunks machen mit etwa 
% 334*2/(334*2+4+73+142)
75 \% bis
% 529*2/(529*2+4+73+142)
82 \% einen Großteil aller Renderables aus. Es wird also bereits ein Großteil der zu zeichnenden Elemente in jedem Frame neu hinzugefügt. Des Weiteren gibt es in der Blocklib bis jetzt keine Klasse, die Renderables zu der Datenstruktur hinzufügt, aber keine Updatemethode besitzt. Somit werden die Gefahr von vergessenen \code{hide()} Aufrufen und der Kopieraufwand des Double Buffers als wichtiger eingeschätzt als die oben beschriebenen Vorteile.

Die Datenstruktur ist nun wie folgt implementiert. Die Methode \code{hide()} entfällt ersatzlos. Stattdessen wird nach dem Swap des Double Buffers der Renderables, der Buffer für die nächsten zu zeichnenden Elemente geleert, sodass Renderables automatisch nicht mehr gezeichnet werden, wenn sie nicht mehr hinzugefügt werden. Die Methode \code{show()} wird zu \code{draw()} umbenannt, um zu signalisieren, dass es sich um einen einmaligen Vorgang handelt. Alle bisherigen Aufrufe von \code{show()} werden durch \code{draw()} ersetzt. Die Update-Methoden aller Klassen, die \class{Renderable}-Objekte anzeigen lassen, nutzen die neue \code{draw()}-Methode, sodass die Objekte jeden Frame zu der Liste der zu zeichnenden Objekte hinzugefügt werden und das Verhalten zum vorherigen Stand identisch ist.

Für den zu zeichnenden Spielercharakter bedeutet dies, dass nun nicht mehr in der \code{init()}-Methode einmal \code{show()} aufgerufen werden kann, damit der Charakter gezeichnet wird, bis er beispielsweise stirbt und mit \code{hide()} entfernt wird. Stattdessen übernimmt die Aufgabe des Zeichnens nun der bereits vorhandene \class{EntityManager}, der Objekte wie den Spielercharakter verwaltet. In der \class{update(...)}-Methode von \class{EntityManager} wird nun während der Iteration über die verwalteten Elemente zum Schluss für jedes Element die \code{draw()}-Methode aufgerufen. Damit wird der Spielercharakter automatisch gerendert, sobald er der Liste der Elemente von \class{EntityManager} hinzugefügt wird. Wird der Spielercharakter aus der Liste entfernt, verschwindet er automatisch.

\subsubsection{Zwischenspeicherung des gerenderten Spielzustands}\label{sec:saveRenderState}
\begin{figure}
	\centering
	\includesvg[width=.8\textwidth]{Rendering.svg}
	\caption{Klassendiagramm Rendering}\label{fig:renderDiagram}
\end{figure}
Aufbauend auf die Änderungen des vorherigen Abschnitts ist nun die Zwischenspeicherung der \class{Renderable}-Objekte vereinfacht, da diese nur für ein Bild gespeichert werden müssen. Die Objekte der Spielwelt werden anders gerendert als die \ac{gui}, da die ihr zugrundeliegende Baumstruktur die Anordnung der Renderables bestimmt. Die Blocklib besitzt eine spezielle Klasse \class{UIRenderer}, die das Rendering der \ac{gui} durchführt. Deswegen unterscheiden sich die Vorgänge zur Zwischenspeicherung des gerenderten Spielzustands der Spielwelt und der \ac{gui}. Abbildung~\vref{fig:renderDiagram} zeigt die wichtigsten Klassen für die Ausführung des Rendering und die Zwischenspeicherung des gerenderten Spielweltzustands. Die Klasse \class{MasterRenderer} übernimmt zwar einen Teil der Zwischenspeicherung, gibt allerdings auch Aufgaben an die anderen in Abbildung~\vref{fig:renderDiagram} gezeigten Klassen ab, wie in den folgenden Abschnitten beschrieben.

Alle in der Abbildung gezeigten Klassen implementieren das Interface \class{DoubleBuffer}, wie in Abbildung~\vref{fig:renderInterfaceDiagram} dargestellt. Zum Großteil wird die Zwischenspeicherung über die von \class{DoubleBuffer} bereitgestellte Methode \code{swapBuffer(): void} implementiert.

Im folgenden Abschnitt wird die Implementierung der Zwischenspeicherung für die Spielwelt erörtert, danach die der \ac{gui}. Im Anschluss daran wird die Zwischenspeicherung weiterer Elemente des Spielzustands beschrieben, die keine \class{Renderable}-Objekte sind.

\begin{figure}
	\centering
	\includesvg[width=.9\textwidth]{Rendering-Interface.svg}
	\caption{Klassendiagramm Rendering}\label{fig:renderInterfaceDiagram}
\end{figure}

\paragraph{Zwischenspeicherung in der Spielwelt} Die Zwischenspeicherung der Renderables erfolgt auf zwei Arten. Zum einen muss gespeichert werden, welche Elemente im aktuellen Frame gezeichnet werden, zum andern muss sichergestellt werden, dass sich der Inhalt der zu zeichnenden \class{Renderable}-Objekte nicht verändert. 

Beim Hinzufügen eines \class{Renderable} in die Menge der zu zeichnenden Objekte mittels der \code{draw()}-Methode, stellt der \class{MasterRenderer} zuerst sicher, dass der zu zeichnende Inhalt sich nicht mehr verändert. Dieser Vorgang ist schematisch in Abbildung~\vref{fig:copyRenderable} dargestellt. Der Inhalt des \class{Renderables}-Objekts wird in ein Objekt der Klasse \class{RenderedRenderable} kopiert, das als Behälter für diese Informationen dient. Da in Java das Erzeugen von Objekten einen gewissen Aufwand verursacht, werden diese \class{RenderedRenderable}-Behälter nach Benutzung wiederverwendet. Dazu wird der Behälter in der Liste \var{usedRenderables} gespeichert.

\begin{figure}
	\centering
	\begin{tikzpicture}
		\node[draw, minimum size = 1cm, label ={RenderedRenderable}] at (0,2) (rr) {};
		\node[draw, minimum size = 1cm, label ={Renderable}] at (-3,2) (r) {};
		\node[draw, minimum size = 1cm, label ={Cache}] at (-3,0) (c) {};
		\node[draw, minimum size = 1cm, label ={usedRenderables}]  at (3,0) (u) {};
		\draw[->, very thick] (c) -- coordinate[pos=.67] (start)  (u);
		\draw[dashed] (rr) -- (0,0);
		\foreach \i in {-.1,.1,.3}{
		\draw[->] ($(r.center)+(0,\i)$) -- ($(rr.center)+(0,\i)$);
		}
		\draw[->] ($(r.center)+(0,-.3)$) -- node[below] {Daten} ($(rr.center)+(0,-.3)$);
		\node[draw,rounded rectangle,anchor=west]  at (2.5,-1.5) (omr) {(Opaque/Transparent)MasterRenderer};
		\draw[->, very thick] (start) |- (omr.west);
		\foreach \i in {-.3,-.1,.1,.3}{
			\draw ($(c.center)+(-.5,\i)$) -- ($(c.center)+(.5,\i)$);
			\draw ($(u.center)+(-.5,\i)$) -- ($(u.center)+(.5,\i)$);
			}
		\end{tikzpicture}
		\caption{Vorgang der Zwischenspeicherung der Daten während eines \code{draw()}-Aufrufs in \class{MasterRenderer}. Ein \class{RenderedRenderable}-Behälter (oben mittig) wird aus der Liste der aktuell nicht benötigten Behälter (Cache) entnommen, in \var{usedRenderables} gespeichert und an den korrekten Renderer übergeben. Die Daten des zu zeichnenden Objekts werden in den \class{RenderedRenderable}-Behälter kopiert.}\label{fig:copyRenderable}
\end{figure}


Betrachtet man nun das vorherige Beispiel der Spielerfigur (also der Klasse \class{Player}), läuft dieser Vorgang wie folgt ab. Die Klasse \class{Player} implementiert indirekt das Interface \class{Renderable}, da sie von der Klasse \class{Entity} abgeleitet ist. Nun wird während der Simulation durch den \class{EntityManager} die \code{draw()}-Methode von \class{Player} aufgerufen. Das \class{Player}-Objekt wird an den \class{MasterRenderer} übergeben. Dieser entnimmt einen \class{RenderedRenderable}-Behälter aus der Liste, der gerade nicht verwendeten Behälter (hier auch \emph{Cache} genannt) und befüllt diesen mit den Daten aus dem \class{Player}-Objekt. Jetzt können Änderungen im \class{Player} vorgenommen werden, ohne dass diese die Daten beeinflussen, die zum Zeichnen benötigt werden. Es wird also genau der Zustand dargestellt, den der \class{Player} hat, während die \code{draw()}-Methode aufgerufen wird. der mit den Daten aus \class{Player} befüllte \class{RenderedRenderable}-Behälter wird nun an den \class{OpaqueMasterRenderer} weitergegeben.


Die Klassen \class{OpaqueMasterRenderer} und \class{TransparentMasterRenderer} sind für das Rendering von undurchsichtigen beziehungsweise durchsichtigen Objekten in der Spielwelt zuständig. Beide implementieren das Interface \class{DoubleBuffer}, um zwischenzuspeichern, welche Elemente in einem Frame gezeichnet werden sollen. Wird die \class{draw()}-Methode einer der beiden Klassen aufgerufen, wird das übergebene \class{Renderable}-Objekt in der Menge \var{nextEntries} gespeichert, die die Elemente enthält, die im folgenden Frame gezeichnet werden sollen. 


Nachdem der \class{MasterRenderer} nun also die Daten des \class{Player}-Objekts in den \class{RenderedRenderable}-Behälter kopiert hat, ruft er die \code{draw()}-Methode von \class{OpaqueMasterRenderer} auf. Dieser nimmt den Behälter entgegen und speichert ihn in \var{nextEntries}.

Nachdem die Simulation für einen Frame abgeschlossen ist, enthalten die \var{nextEntries} Mengen von \class{OpaqueMasterRenderer} und \class{TransparentMasterRenderer} alle Objekte der Welt, die im nächsten Frame gezeichnet werden sollen. 

\begin{figure}
	\centering
	\begin{tikzpicture}[scale=.9]
		\usetikzlibrary{calc,positioning}
		\newlength\testl
		\pgfmathsetlength\testl{.9cm}
		\node[draw, minimum size = \testl, label={Cache} ] at (0,0) (c) {};
	
		\node[draw,rounded rectangle, anchor=west, font={\small\ttfamily}] at (1.5,1) (ur) {usedRenderables};
		\node[draw,rounded rectangle, anchor=west, font={\small\ttfamily}] at (1.5,-1) (lur) {lastUsedRenderables};
	
		\node[draw, minimum size = \testl, right = 4.5 of ur.west,] (u) {};
		\node[draw, minimum size = \testl, right = 4.5 of lur.west,] (lu) {};
	
		\foreach \i in {-.3,-.1,.1,.3}{
			\draw ($(c.west)+(0,\i)$) -- ($(c.east)+(0,\i)$);
			\draw ($(u.west)+(0,\i)$) -- ($(u.east)+(0,\i)$);
			\draw ($(lu.west)+(0,\i)$) -- ($(lu.east)+(0,\i)$);
		}
	
		\draw (ur.east) -- (u.west);
		\draw (lur.east) -- (lu.west);
		\draw[->] (lu) to [bend right=10] node[above, sloped] {verschieben}  (c);
		\draw (-1, -2) rectangle coordinate (label) (8,2);
			\node[anchor= south] at (label |- 0,2) {Schritt 1};
	
		\begin{scope}[shift={(9.5,0)}]
			\node[draw, minimum width = \testl, minimum height= 2\testl, label={Cache} ] at (0,0) (c) {};
		
			\node[draw,rounded rectangle, anchor=west, font={\small\ttfamily}] at (1.5,1) (ur) {usedRenderables};
			\node[draw,rounded rectangle, anchor=west, font={\small\ttfamily}] at (1.5,-1) (lur) {lastUsedRenderables};
		
			\node[draw, minimum size = \testl, right = 4.5 of ur.west,] (u) {};
			\node[draw, minimum size = \testl, right = 4.5 of lur.west,] (lu) {};
	
			\foreach \i in {-.8,-.6,...,.8}{
				\draw ($(c.west)+(0,\i)$) -- ($(c.east)+(0,\i)$);
			}
		
			\foreach \i in {-.3,-.1,.1,.3}{
				\draw ($(u.west)+(0,\i)$) -- ($(u.east)+(0,\i)$);
			}
		
			\draw (ur.east) -- (lu.west);
			\draw (lur.east) -- (u.west);
			\draw (-1, -2) rectangle coordinate (label) (8,2);
			\node[anchor= south] at (label |- 0,2) {Schritt 2};
		\end{scope}
	
		\end{tikzpicture}
		\caption{Wechsel der Puffer in \class{MasterRenderer} während \code{swapBuffer()}. In Schritt 1 wird der Inhalt von \var{lastUsedRenderables} in den Cache verschoben. In Schritt 2 werden die Listen von \var{usedRenderables} und \var{lastUsedRenderables} vertauscht.}\label{fig:mrSwapBuffer}
\end{figure}

Im nächsten Frame müssen diese Elemente gezeichnet werden. Zu Beginn des Frames werden alle Puffer der \class{Renderer}-Klassen mittels der \code{swapBuffer}-Methode getauscht. Die Klasse \class{MasterRenderer} fügt, wie in Abbildung~\vref{fig:mrSwapBuffer} dargestellt, alle im letzten Frame für das Rendering verwendeten Behälter (gespeichert in \var{lastUsedRenderables}) der Liste der nicht mehr verwendeten Behälter hinzu und leert dann \var{lastUsedRenderables}. Danach vertauscht er die Listen der benutzten und zuletzt benutzten Behälter, sodass \var{usedRenderables} nun eine leere Liste ist, der während der Simulation wieder benutzte Behälter hinzugefügt werden können. \class{OpaqueMasterRenderer} und \class{TransparentMasterRenderer} tauschen jeweils ihre Puffer \var{entries} und \var{nextEntries} und leeren danach \var{nextEntries}, sodass während der Simulation die im nächsten Frame zu zeichnenden Objekte eingefügt werden können.

Nach dieser Phase findet sich nun also der Behälter, der die unveränderten Daten des \class{Player}-Objekts enthält, durch den Puffertausch in der Liste \var{lastUsedRenderables} in \class{MasterRenderer} und in \class{OpaqueMasterRenderer} in der \var{entries}-Menge. Während des Renderings zeichnet der \class{OpaqueMasterRenderer} Elemente der \var{entries}-Menge.

Im folgenden Frame werden während \code{swapBuffer()} wieder alle Puffer getauscht, wodurch der \class{RenderedRenderable}-Behälter der \class{Player}-Daten aus der Menge von \class{OpaqueMasterRenderer} entfernt wird und in die Menge der nicht genutzten Behälter von \class{MasterRenderer} eingefügt wird, um später wieder als Behälter für die Daten eines anderer \class{Renderable} genutzt werden zu können. Damit ist ein Zyklus der Zwischenspeicherung durchlaufen. 

\paragraph{Zwischenspeicherung in der \glsentryshort{gui}}
Die \ac{gui}-Elemente werden dagegen von der Klasse \class{UIRenderer} verwaltet und werden nicht jeden Frame zu einer Menge von zu zeichnenden Elementen hinzugefügt. 
Stattdessen wird die Baumstruktur der \ac{gui} durchlaufen und jedes Element gezeichnet, das das Attribut \var{visible} als \code{true} gesetzt hat. Daher kann der im letzten Abschnitt beschriebene Vorgang nicht für das Rendering der \ac{gui} verwendet werden. Dennoch muss auch für die \ac{gui} der Spielzustand zwischengespeichert werden, da sonst ebenfalls Wettkampfbedingungen auftreten. Zum Beispiel kann es dann vorkommen, dass sich die Breite von gezeichnetem Text scheinbar zufällig von Frame zu Frame verändert. Für die Zwischenspeicherung des \ac{gui}-Zustands wird die Tatsache ausgenutzt, dass im Gegensatz zu den Objekten der Spielwelt alle \ac{gui}-Elemente von einer Klasse, \class{UIItem}, abgeleitet sind. Diese Klasse definiert das \class{Renderable}-Objekt, das zur Darstellung eines \ac{gui}-Elements genutzt wird. 

Um die Zwischenspeicherung zu implementieren wird das \class{Renderable}-Objekt durch die in Abbildung~\vref{fig:renderDiagram} bereits dargestellte Klasse \class{DoubleBufferedUIRenderable} ersetzt, die für jedes \ac{gui}-Element die Zwischenspeicherung übernimmt. Die Klasse enthält zwei Objekte des Typs \class{UIRenderable}, die während des \code{swapBuffer()}-Aufrufs synchronisiert getauscht werden. Zudem wird zeitgleich der Inhalt des geänderten \class{UIRenderable} in das ältere und konstante Objekt kopiert. So zeichnet \class{UIRenderer} Elemente, die während des Renderings unverändert bleiben.


\paragraph{Zwischenspeicherung des restlichen gerenderten Spielzustands} Neben der Informationen, die in den  \class{Renderable}-Objekten gespeichert sind, umfasst der für das Rendering relevante Spielzustand noch weitere Daten. 
Die Blocklib enthält sogenannte \emph{globale} \glspl{uniform}. Ein \gls{uniform}~\cite[S.~45~ff.]{Vries2020} ist eine globale Variable die in einem \gls{shaderprogram} definiert wird. Ein \gls{shaderprogram}~\cite[S.~32~f.]{Vries2020} ist ein Programm, das auf der \ac{gpu} ausgeführt wird. Die in der Blocklib als globale \glspl{uniform} bezeichneten Variablen sind \glspl{uniform}, die alle \glspl{shaderprogram} nutzen können, also auch über die \glspl{shaderprogram} hinweg global sind. Da sich in den globalen \glspl{uniform} Informationen wie die Position und Blickrichtung der Kamera gespeichert sind, müssen auch diese Daten während des Renderings unverändert bleiben. Die Simulation ändert beispielsweise die Position der Kamera, wenn eine Bewegungstaste gedrückt wird. Daher müssen die globalen \glspl{uniform} ebenfalls zwischengespeichert werden.

Die globalen \glspl{uniform} sind in der Klasse \class{GlobalUniforms} als statische Attribute gespeichert. Deswegen lässt sich dafür nicht ohne großen Aufwand ein normaler Double-Buffer verwenden. Alle Objekte, die auf die Attribute zugreifen, müssten so angepasst werden, dass sie nicht auf statische Werte zugreifen sondern auf eine Instanz der Klasse und alle statischen Attribute müssten zu Objektattributen geändert werden.

Daher wird ein Double-Buffer für die \emph{Änderung} der globalen \glspl{uniform} genutzt. Die Klasse \class{MasterRenderer} besitzt dafür zwei \class{Runnable}-Objekte \var{setUniforms} und \var{nextSetUniforms}. Die öffentliche Methode \code{setGlobalUniforms()} von \class{MasterRenderer} führt die Änderungen so wie die Klasse \class{Loader} nun nicht sofort durch sondern speichert die Anweisungen in \var{nextSetUniforms}. In der \code{swapBuffer}-Methode werden \var{setUniforms} und \var{nextSetUniforms} synchronisiert vertauscht und die gespeicherten Anweisungen werden vor dem Rendering ausgeführt. Somit ist der Zustand der globalen \glspl{uniform} aus Sicht des Renderthreads konstant.

\subsubsection{Anpassung der Game-Loop}\label{sec:adjustGameLoop}
Die Game-Loop wird in eine Klasse \class{GameLoop} ausgelagert, um die für den Vorgang nötigen Methoden und Attribut von den restlichen Elementen der \class{Game}-Klasse zu trennen. Da diese beiden Klassen allerdings weiterhin eng miteinander gekoppelt sind, ist \class{GameLoop} als innere Klasse in \class{Game} implementiert. Ein Klassendiagramm von  \class{GameLoop} mit allen Attributen und Methoden ist in Abbildung~\vref{fig:DiagGameLoop} zu sehen.
\begin{figure}[htbp]
	\centering
	\includesvg[scale=.8]{GameLoop.svg}
	\caption{Klassendiagramm der nun für die Game-Loop zuständigen Klasse \class{GameLoop}.}\label{fig:DiagGameLoop}
\end{figure}
Die Klasse definiert eine öffentliche Methode \code{start(): void}, die die Game-Loop startet.