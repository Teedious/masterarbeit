Da ein Jobsystem implementiert wird, bietet sich der \code{main}-Thread als Renderthread an. Alle anderen Rechenprozesse werden über das Jobsystem auf anderen Threads ausgeführt. Bei der Implementierung der für einen Renderthread nötigen Funktionalität müssen in der Blocklib viele verschiedene Klassen angepasst werden. Der Übersichtlichkeit halber werden die Anpassungen in Bereiche eingeteilt. 

In Abschnitt~\ref{sec:loader} wird beschrieben, wie das Laden von Daten auf die \ac{gpu} geändert werden muss, nachdem dieser Vorgang aus Sicht der Simulation nun wegen der Nebenläufigkeit des Renderthreads asynchron ist. Danach erläutert Abschnitt~\ref{sec:statelessRendering} den Wechsel von einer Renderarchitektur,die sich zu zeichnende Elemente merkt, zu einer zustandslosen Architektur. Abschnitt~\ref{sec:saveRenderState} beschreibt, wie darauf aufbauend der Zustand der zu zeichnenden Elemente unter Verwendung von Double-Buffers zwischengespeichert wird, damit er während des Renderings unverändert bleibt. In Abschnitt~\ref{sec:adjustGameLoop} wird schließlich beschrieben, wie der Aufbau der Game-Loop an die neue Architektur angepasst wird.

\subsubsection{Laden von Daten auf die \glsentryuseri{gpu}}\label{sec:loader}
In der Blocklib werden häufig Daten an die \ac{gpu} übergeben. Beispielsweise muss bei der Generierung eines Chunks ein Gitternetz konstruiert werden, das die Form des Terrains im Chunk beschreibt, und dann an die \ac{gpu} gesendet werden. Dafür wird die OpenGL API genutzt. Da alle Aufrufe an OpenGL auf einem Thread ausgeführt werden müssen, ist dafür zu sorgen, dass Anweisungen zwischengespeichert werden, die mit der \ac{gpu} interagieren, aber zum Beispiel durch die Chunkgenerierung angestoßen werden. Dann können die zwischengespeicherten Anweisungen vom Renderthread ausgelesen und ausgeführt werden. 

Um Anweisungen zum Laden von Daten auf die \ac{gpu} zwischenzuspeichern, muss die dafür zuständige Klasse \class{Loader} angepasst werden. Die Klasse wird um eine Warteschlange erweitert, die Objekte vom Typ \class{Runnable} enthält. Anstatt die Ladeanweisungen direkt auszuführen, werden sie als Tasks der Warteschlange übergeben und dort als \class{Runnable}-Objekte gespeichert. Die Warteschlange nutzt intern die von Java bereitgestellte Klasse \class{ConcurrentLinkedQueue}. Die Warteschlange bietet damit nicht-blockierende Synchronisierung, wodurch mehrere Threads gleichzeitig Elemente der Warteschlange hinzufügen können, ohne dass das zu Wettkampfbedingungen führen kann. In der Game-Loop der Blocklib wird diese Warteschlange zu Beginn vom Renderthread abgearbeitet, damit danach sowohl die Simulation als auch der Renderer darauf Zugriff haben. 

\begin{figure}
	\includesvg{Loader.svg}
	\caption{Klassendiagramm der wichtigsten Klassen, die am Laden und Entfernen von Daten auf und von der \ac{gpu} beteiligten sind. Zum Laden wird der Loader aufgerufen, dieser erstellt einen Task, der eine der drei Transmitter-Klassen aufruft. Die so erstellten Tasks werden an \class{DoubleBufferedAsyncQueue} übergeben, die ein \class{CompletableFuture}-Objekt zurückgibt.}\label{fig:loaderDiagram}
\end{figure}
Ein Diagramm der wichtigsten beteiligten Klassen ist in Abbildung~\vref{fig:loaderDiagram} gezeigt. Im Klassendiagramm sind die drei Klassen \class{VAOTransmitter}, \class{TextureTransmitter} und \class{DataTransmitter} abgebildet. Die Klasse \class{Loader} erzeugt Tasks, die dann Methoden dieser Klassen aufrufen, je nachdem, welche Art von Daten an die \ac{gpu} übertragen oder von dor gelöscht werden soll. Die Klasse \class{VAOTransmitter} ermöglicht den Umgang mit sogenannten \acp{vao}. Das ist eine Datenstruktur, die alle relevanten Informationen zur Darstellung eines Modells enthält, beispielsweise eines Chunks oder des Spielercharakters. Mit der Klasse \class{TextureTransmitter} lassen sich Texturen übertragen, die beispielsweise das Aussehen von Blöcken definieren. Der \class{DataTransmitter} wird genutzt, um die Daten an die \ac{gpu} zu senden, die für die Berechnung von Niederschlag, wie Regen und Schnee, benötigt werden.


Die Abarbeitung aller Ladevorgänge der Klasse \class{Loader} muss synchronisiert sein, da die Simulation sonst beispielsweise versuchen könnte ein Objekt rendern zu lassen, das noch nicht geladen wurde. Nachdem die Daten eines Objekts auf die \ac{gpu} geladen worden sind, kann das Objekt dann gerendert werden.

\subsubsection{Zustandsloses Rendering}\label{sec:statelessRendering}
In der Blocklib implementieren alle zu zeichnenden Elemente das Interface \class{Renderable}. Dieses definiert die Funktionalität, die zum Zeichnen eines Elements notwendig ist, sowie die Methoden \code{show()} und \code{hide()}. Das Rendersystem ist so aufgebaut, dass ein Element nach einem Aufruf von \code{show()} solange gezeichnet wird, bis \code{hide()} aufgerufen wird. Dies wird erreicht, indem eine Datenstruktur im \class{MasterRenderer} alle Renderables speichert. Diese zustandsbehaftete Zeichenmethode birgt Vor- und Nachteile.

\begin{itemize}
	\item[$+$] Da \code{show()} nur einmal aufgerufen werden muss, können auch Systeme ohne Updatemethode das Zeichnen von Elementen veranlassen.
	\item[$+$] Da die Elemente gespeichert sind, müssen sie nicht jedes Mal neu hinzugefügt werden. Das verringert den Rechenbedarf.
	\item[$-$] Werden Renderables häufig ausgetauscht, müssen die alten Elemente jedes Mal entfernt werden.
	\item[$-$] Da die Einführung eines parallelen Renderthreads ansonsten zu Race Conditions führen würde, muss diese Datenstruktur aus Sicht des Renderthreads während des Zeichnens unverändert sein. Wie beschrieben, wird dazu ein Double Buffer eingesetzt. Bei einem zustandsbehafteten Double Buffer müssen beim Swap die Elemente des einen Buffers in den anderen Buffer kopiert werden. Das erfordert Zeit, die nicht parallelisiert werden kann, da das Wechseln des Buffers synchronisiert sein muss.
	\item[$-$] Die Existenz von paarweise aufzurufenden Funktionen birgt die Gefahr, dass der zweite Aufruf vergessen wird. Wie bei \code{malloc()} und \code{free()} in C entsteht durch einen fehlenden Aufruf von \code{hide()} ein Speicherleck. Zudem wird dann die Anzahl der zu zeichnenden Elemente immer größer und der Rendervorgang wird verlangsamt. Des Weiteren werden möglicherweise Renderables gezeichnet, die nicht gezeichnet werden sollen.
\end{itemize}

Um den Zeichenaufwand zu verringern, implementiert die Klasse \class{ChunkManager} das sogenannte \emph{Frustum Culling}. Es wird berechnet, welche Chunks sich im Sichtfeld der Kamera befinden. Nur diese Chunks sollen gezeichnet werden. Dazu entfernt der ChunkManager jeden Frame alle Chunks mittels \code{hide()} aus der Datenstruktur der zu zeichnenden Elemente und fügt nur die als sichtbar ermittelten Chunks wieder ein. Die Chunks machen mit etwa 
% 334*2/(334*2+4+73+142)
75 \% bis
% 529*2/(529*2+4+73+142)
82 \% einen Großteil aller Renderables aus. Es wird also bereits ein Großteil der zu zeichnenden Elemente in jedem Frame neu hinzugefügt. Des Weiteren gibt es in der Blocklib bis jetzt keine Klasse, die Renderables zu der Datenstruktur hinzufügt, aber keine Updatemethode besitzt. Somit werden die Gefahr von vergessenen \code{hide()} Aufrufen und der Kopieraufwand des Double Buffers als wichtiger eingeschätzt als die oben beschriebenen Vorteile.

Die Datenstruktur ist nun wie folgt implementiert. Die Methode \code{hide()} entfällt ersatzlos. Stattdessen wird nach dem Swap des Double Buffers der Renderables, der Buffer für die nächsten zu zeichnenden Elemente geleert, sodass Renderables automatisch nicht mehr gezeichnet werden, wenn sie nicht mehr hinzugefügt werden. Die Methode \code{show()} wird zu \code{draw()} umbenannt, um zu signalisieren, dass es sich um einen einmaligen Vorgang handelt. Alle bisherigen Aufrufe von \code{show()} werden durch \code{draw()} ersetzt. Die Update-Methoden aller Klassen, die \class{Renderable}-Objekte anzeigen lassen, nutzen die neue \code{draw()}-Methode, sodass die Objekte jeden Frame zu der Liste der zu zeichnenden Objekte hinzugefügt werden und das Verhalten zum vorherigen Stand identisch ist.

\subsubsection{Zwischenspeicherung des gerenderten Spielzustands}\label{sec:saveRenderState}
Aufbauend auf die Änderungen des vorherigen Abschnitts ist nun die Zwischenspeicherung der \class{Renderable}-Objekte vereinfacht, da diese nur für ein Bild gespeichert werden müssen. 

Neben den Informationen, die in den  \class{Renderable}-Objekten gespeichert ist, umfasst der für das Rendering relevante Spielzustand noch weitere Daten. Die Zwischenspeicherung der Renderables erfolgt auf zwei Arten. Zum einen muss gespeichert werden, welche Elemente im aktuellen Frame gezeichnet werden, zum andern muss sichergestellt werden, dass sich der Inhalt der zu zeichnenden \class{Renderable}-Objekte nicht verändert. Die \ac{gui} wird auf eine andere Weise gezeichnet, als andere Elemente, da die ihr zugrundeliegende Baumstruktur die Anordnung der Renderables bestimmt. Die Blocklib besitzt eine spezielle Klasse \class{UIRenderer}, die das Rendering der \ac{gui} durchführt. Abbildung~\vref{fig:renderDiagram} zeigt die wichtigsten Klassen für die Ausführung des Rendering und die Zwischenspeicherung des gerenderten Spielzustands.
\begin{figure}
	\centering
	\includesvg{Rendering.svg}
	\caption{Klassendiagramm Rendering}\label{fig:renderDiagram}
\end{figure}
Alle in der Abbildung gezeigten Klassen implementieren das Interface \class{DoubleBuffer}, wie in Abbildung~\vref{fig:renderInterfaceDiagram} dargestellt.
\begin{figure}
	\centering
	\includesvg[width=\textwidth]{Rendering-Interface.svg}
	\caption{Klassendiagramm Rendering}\label{fig:renderInterfaceDiagram}
\end{figure}



Die Blocklib enthält sogenannte \emph{globale} \glspl{uniform}. Ein \gls{uniform}~\cite[S.~45~ff.]{Vries2020} ist eine globale Variable die in einem \gls{shaderprogram} definiert wird. Ein \gls{shaderprogram} ist ein Programm, das auf der \ac{gpu} ausgeführt wird~\cite[S.~32~f.]{Vries2020}. Die in der Blocklib als globale \glspl{uniform} bezeichneten Variablen sind \glspl{uniform}, die alle \glspl{shaderprogram} nutzen können, also auch über die \glspl{shaderprogram} hinweg global sind. Da sich in den globalen \glspl{uniform} Informationen wie die Position und Blickrichtung der Kamera gespeichert sind, müssen auch diese Daten während des Renderings unverändert bleiben. Die Simulation ändert beispielsweise die Position der Kamera, wenn eine Bewegungstaste gedrückt wird. Daher müssen die globalen \glspl{uniform} ebenfalls zwischengespeichert werden.

Die globalen \glspl{uniform} sind in der Klasse \class{GlobalUniforms} als statische Attribute gespeichert.


\subsubsection{Anpassung der Game-Loop}\label{sec:adjustGameLoop}