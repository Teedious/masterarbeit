Da ein Jobsystem implementiert wird, bietet sich der \code{main}-Thread als Renderthread an. Alle anderen Rechenprozesse werden über das Jobsystem auf anderen Threads ausgeführt. Bei der Implementierung der für einen Renderthread nötigen Funktionalität müssen in der Blocklib viele verschiedene Klassen angepasst werden. Der Übersichtlichkeit halber werden die Anpassungen in Bereiche eingeteilt. 

In Abschnitt~\ref{sec:loader} wird beschrieben, wie das Laden von Daten auf die \ac{gpu} geändert werden muss, nachdem dieser Vorgang aus Sicht der Simulation nun wegen der Nebenläufigkeit des Renderthreads asynchron ist. Danach erläutert Abschnitt~\ref{sec:statelessRendering} den Wechsel von einer Renderarchitektur,die sich zu zeichnende Elemente merkt, zu einer zustandslosen Architektur. Abschnitt~\ref{sec:saveRenderState} beschreibt, wie darauf aufbauend der Zustand der zu zeichnenden Elemente unter Verwendung von Double-Buffers zwischengespeichert wird, damit er während des Renderings unverändert bleibt. In Abschnitt~\ref{sec:adjustGameLoop} wird schließlich beschrieben, wie der Aufbau der Game-Loop an die neue Architektur angepasst wird.

\subsubsection{Laden von Daten auf die \glsentryuseri{gpu}}\label{sec:loader}
In der Blocklib werden häufig Daten an die \ac{gpu} übergeben. Beispielsweise muss bei der Generierung eines Chunks ein Gitternetz konstruiert werden, das die Form des Terrains im Chunk beschreibt, und dann an die \ac{gpu} gesendet werden. Dafür wird die OpenGL API genutzt. Da alle Aufrufe an OpenGL auf einem Thread ausgeführt werden müssen, ist dafür zu sorgen, dass Anweisungen zwischengespeichert werden, die mit der \ac{gpu} interagieren, aber beispielsweise durch die Chunkgenerierung angestoßen werden. Dann können die zwischengespeicherten Anweisungen vom Renderthread ausgelesen und ausgeführt werden. 

Um Anweisungen zum Laden von Daten auf die \ac{gpu} zwischenzuspeichern, muss die dafür zuständige Klasse \class{Loader} angepasst werden. Die Klasse wird um eine Warteschlange erweitert, die Objekte vom Typ \class{Runnable} enthält. Anstatt die Ladeanweisungen direkt auszuführen, werden sie als Tasks der Warteschlange übergeben und dort als \class{Runnable}-Objekte gespeichert. Die Warteschlange nutzt intern die von Java bereitgestellte Klasse \class{ConcurrentLinkedQueue}. Die Warteschlange bietet damit nicht-blockierende Synchronisierung, wodurch mehrere Threads gleichzeitig Elemente der Warteschlange hinzufügen können, ohne dass das zu Wettkampfbedingungen führen kann. In der Game-Loop der Blocklib wird diese Warteschlange zu Beginn vom Renderthread abgearbeitet, damit danach sowohl die Simulation als auch der Renderer darauf Zugriff haben. 

Ein Diagramm der wichtigsten beteiligten Klassen ist in Abbildung~\vref{fig:loaderDiagram} gezeigt. Im Klassendiagramm sind die drei Klassen \class{VAOTransmitter}, \class{TextureTransmitter} und \class{DataTransmitter} abgebildet. Die Klasse \class{Loader} erzeugt Tasks, die dann Methoden dieser Klassen aufrufen, je nachdem, welche Art von Daten an die \ac{gpu} übertragen oder von dor gelöscht werden soll. Die Klasse \class{VAOTransmitter} ermöglicht den Umgang mit sogenannten \acp{vao}. Das ist eine Datenstruktur, die alle relevanten Informationen zur Darstellung eines Modells enthält, beispielsweise eines Chunks oder des Spielercharakters. Mit der Klasse \class{TextureTransmitter} lassen sich Texturen übertragen, die beispielsweise das Aussehen von Blöcken definieren. Der \class{DataTransmitter} wird genutzt, um die Daten an die \ac{gpu} zu senden, die für die Berechnung von Niederschlag, wie Regen und Schnee, benötigt werden.
\begin{figure}
	\includesvg{Loader.svg}
	\caption{Klassendiagramm der wichtigsten Klassen, die am Laden und Entfernen von Daten auf und von der \ac{gpu} beteiligten sind.}\label{fig:loaderDiagram}
\end{figure}

Die Abarbeitung aller Ladevorgänge der Klasse \class{Loader} muss synchronisiert sein, da die Simulation sonst beispielsweise versuchen könnte ein Objekt, das noch nicht geladen wurde, rendern zu lassen. 

\subsubsection{Zustandsloses Rendering}\label{sec:statelessRendering}
In der Blocklib implementieren alle zu zeichnenden Elemente das Interface \class{Renderable}. Dieses definiert die Funktionalität, die zum Zeichnen eines Elements notwendig ist, sowie die Methoden \code{show()} und \code{hide()}. Das Rendersystem ist so aufgebaut, dass ein Element nach einem Aufruf von \code{show()} solange gezeichnet wird, bis \code{hide()} aufgerufen wird. Dies wird erreicht, indem eine Datenstruktur im \class{MasterRenderer} alle Renderables speichert. Diese zustandsbehaftete Zeichenmethode birgt Vor- und Nachteile.

\begin{itemize}
	\item[$+$] Da \code{show()} nur einmal aufgerufen werden muss, können auch Systeme ohne Updatemethode das Zeichnen von Elementen veranlassen.
	\item[$+$] Da die Elemente gespeichert sind, müssen sie nicht jedes Mal neu hinzugefügt werden. Das verringert den Rechenbedarf.
	\item[$-$] Werden Renderables häufig ausgetauscht, müssen die alten Elemente jedes Mal entfernt werden.
	\item[$-$] Da die Einführung eines parallelen Renderthreads ansonsten zu Race Conditions führen würde, muss diese Datenstruktur aus Sicht des Renderthreads während des Zeichnens unverändert sein. Wie beschrieben, wird dazu ein Double Buffer eingesetzt. Bei einem zustandsbehafteten Double Buffer müssen beim Swap die Elemente des einen Buffers tatsächlich in den anderen Buffer kopiert werden. Das erfordert Zeit, die nicht parallelisiert werden kann, da das Wechseln des Buffers synchronisiert sein muss.
	\item[$-$] Die Existenz von paarweise aufzurufenden Funktionen birgt die Gefahr, dass der zweite Aufruf vergessen wird. Wie bei \code{malloc()} und \code{free()} in C entsteht durch einen fehlenden Aufruf von \code{hide()} ein Speicherleck. Zudem wird dann die Anzahl der zu zeichnenden Elemente immer größer und der Rendervorgang wird verlangsamt. Des Weiteren werden möglicherweise Renderables gezeichnet, die nicht gezeichnet werden sollen.
\end{itemize}

Um den Zeichenaufwand zu verringern, implementiert die Klasse \class{ChunkManager} das sogenannte \emph{Frustum Culling}. Es wird berechnet, welche Chunks sich im Sichtfeld der Kamera befinden. Nur diese Chunks sollen gezeichnet werden. Dazu entfernt der ChunkManager jeden Frame alle Chunks mittels \code{hide()} aus der Datenstruktur der zu zeichnenden Elemente und fügt nur die als sichtbar ermittelten Chunks wieder ein. Die Chunks machen mit etwa 
% 334*2/(334*2+4+73+142)
75 \% bis
% 529*2/(529*2+4+73+142)
82 \% einen Großteil aller Renderables aus. Es wird also bereits ein Großteil der zu zeichnenden Elemente in jedem Frame neu hinzugefügt. Des Weiteren gibt es in der Blocklib bis jetzt keine Klasse, die Renderables zu der Datenstruktur hinzufügt, aber keine Updatemethode besitzt. Somit werden die Gefahr von vergessenen \code{hide()} Aufrufen und der Kopieraufwand des Double Buffers als wichtiger eingeschätzt als die oben beschriebenen Vorteile.

Die Datenstruktur ist nun wie folgt implementiert. Die Methode \code{hide()} entfällt ersatzlos. Stattdessen wird nach dem Swap des Double Buffers der Renderables, der Buffer für die nächsten zu zeichnenden Elemente geleert, sodass Renderables automatisch nicht mehr gezeichnet werden, wenn sie nicht mehr hinzugefügt werden. Die Methode \code{show()} wird zu \code{draw()} umbenannt, um zu signalisieren, dass es sich um einen einmaligen Vorgang handelt. Alle bisherigen Aufrufe von \code{show()} werden durch \code{draw()} in Updatemethoden ersetzt, sodass das Verhalten zum vorherigen Stand identisch ist.

\subsubsection{Zwischenspeicherung des gerenderten Spielzustands}\label{sec:saveRenderState}


\subsubsection{Anpassung der Game-Loop}\label{sec:adjustGameLoop}