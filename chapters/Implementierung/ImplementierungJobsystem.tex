Bei der Implementierung des Jobsystems liegt die Aufgabe insbesondere darin, die Verkettung von Jobs durch \class{CompletableFuture} zu ermöglichen. Diese Verkettung ist nämlich die Voraussetzung dafür, dass die Simulation später Schritt für Schritt in Jobs zerlegt werden kann, die dann aufeinander aufbauen und einen Jobgraphen bilden. 

Während der Implementierung ist eine weitere Anforderung zum Vorschein gekommen, die aufgrund des Zeitpunkts, zu dem sie aufgetaucht ist, nicht vollständig gelöst ist. Dabei handelt es sich um die in Abschnitt~\ref{sec:reqBackgroundTasks} beschriebene Anforderung, die Ausführung von Hintergrundtasks zu ermöglichen, ohne die Ausführung anderer Tasks zu blockieren. 

Den Zugriffspunkt auf das Jobsystem bietet das neu definierte Interface \class{BlocklibExecutorService}, das von der Klasse \class{BlocklibExecutor} implementiert wird. Ein gekürztes Klassendiagramm ist in Abbildung~\ref{fig:diag-BlocklibExecutor} dargestellt.

\begin{figure}[!htb]
	\centering
	\includesvg[width=\textwidth]{BlocklibExecutor-shortened.svg}
	\caption[Gekürztes Klassendiagramm von \class{BlocklibExecutor}.]{Klassendiagramm von \class{BlocklibExecutor}, das nur die \emph{nicht} von dem Interface \class{BlocklibExecutorService} definierten Attribute und Methoden zeigt.}\label{fig:diag-BlocklibExecutor}
\end{figure}

Von der Klasse \class{BlocklibExecutor} soll dauerhaft nur eine Instanz existieren, damit die Verwaltung der nebenläufigen Threads von einer Stelle aus stattfinden. Es steht in Aussicht, dass die Nutzung globaler Objekte wie \class{Context} in Zukunft verringert wird. Das wird noch genauer im Ausblick in Abschnitt~\ref{sec:EtablierungEinerKompositionroot} erläutert. Daher wird bei hier nicht auf das Entwurfsmuster \gls{singleton} zurückgegriffen, sondern das in den Grundlagen beschriebene lokale Singleton-Design implementiert. Um sicherzustellen, dass von der Klasse nur eine Instanz erzeugt wird, enthält \class{BlocklibExecutor} ein statisches Attribut \var{instanced: AtomicBoolean}. Beim Aufruf des Konstruktors wird mit der Methode \code{ensureUniqueInstance()} geprüft, ob bereits eine Instanz der Klasse erzeugt worden ist. \var{instanced} besitzt den Typ \code{AtomicBoolean}, um sicherzustellen, dass diese Prüfung nicht-blockierend synchronisiert ist. Existiert bereits eine Instanz, wird eine \class{UnsupportedOperationException} geworfen, die darauf hinweist.

Die Klasse besitzt Referenzen auf zwei Instanzen von \class{ScheduledThreadPoolExecutor}. Damit wird die Anforderung, unterschiedliche Prioritäten von Jobs zu unterstützen behelfsmäßig unterstützt. Im Gegenzug wird jedoch darauf verzichtet, die Anzahl der Java-Threads genau an die Anzahl der Hardware-Threads anzupassen. Für jeden der beiden \class{ScheduledThreadPoolExecutor} werden $\text{Anzahl(Hardware-Threads)} - 1$ Java-Threads erzeugt. Damit entsteht zwar ein Wettstreit um die Belegung der Hardware-Threads, aber nur, wenn in beiden Systemen auch genügend Jobs gleichzeitig vorhanden sind. Aktuell ist das in der Regel nicht der Fall, da die Simulation noch weitgehend sequentiell als ein Job auf einem Thread ausgeführt wird und die konsolidierten Jobs sehr unregelmäßig sind. Die Konsolidierung der bereits vorhandenen Nebenläufigkeit in das Jobsystem wird in Abschnitt~\ref{sec:Konsolidierung} noch genauer erläutert. 

In den folgenden Abschnitten wird die Implementierung des Jobsystems erläutert indem die unterschiedlichen Aufgabenbereich jeweils näher beleuchtet werden. Zuerst wird in Abschnitt~\ref{sec:Koordinierung} näher beschrieben, wie die Koordinierung das Jobsystems aufgebaut ist und wie andere Module auf das Jobsystem zugreifen können. In Abschnitt~\ref{sec:Verkettung} wird beschrieben, wie das System die Komposition von Jobs ermöglicht. Zuletzt wird in Abschnitt~\ref{sec:Konsolidierung} die oben bereits erwähnte Konsolidierung von Blocklib und Jobsystem beschrieben.

\subsubsection{Koordinierung durch \texttt{BlocklibExecutor}}\label{sec:Koordinierung}

Wie bereits beschrieben dient die Klasse \class{BlocklibExecutor} als Zugriffspunktpunkt auf das neu implementierte Jobsystem, indem sie das Interface \class{BlocklibExecutorService} implementiert. Um der Bibliothek möglichst früh zur Verfügung zu stehen, wird \class{BlocklibExecutor} im Konstruktor der \class{Game}-Klasse instanziiert, die als Einstiegspunkt für die Blocklib dient. Wie die Abbildung~\ref{fig:diag-BlocklibExecutor} zeigt, besitzt die Klasse \class{BlocklibExecutor} eine statische Methode \code{defaultConfig()}, die eine \class{BlocklibExecutor}-Instanz in einer Standardkonfiguration erzeugt.

Aktuell bedeutet das, dass die oben erwähnten \class{ScheduledThreadPoolExecutor} erzeugt werden und jeweils $\text{Anzahl(Hardware-Threads)} - 1$ Java-Threads besitzen. Um die Threads beispielsweise beim Debugging zuordnen zu können, werden die Threads über die neue Klasse \class{NamedThreadFactory} erzeugt, die es ermöglicht den erzeugten Threads ein Namenspräfix zu geben. Dadurch besitzen alle Job-Threads den Namen \emph{Jobs-thread-\{x\}} und alle Hintergrund-Threads den Namen \emph{Background-thread-\{x\}}, wobei \{x\} jeweils durch eine Zahl von 1 bis $\text{Anzahl(Hardware-Threads)} - 1$ ersetzt wird.

Die in \class{Game} erzeugte \class{BlocklibExecutor}-Instanz wird dann unter anderem an den Konstruktor der \class{Context}-Klasse übergeben, die momentan für die Instanziierung der meisten Module der Blocklib verantwortlich ist. Hier wird der \class{BlocklibExecutor} an die Konstruktoren der Module übergeben, die das Jobsystem nutzen.

Die Implementierung von priorisierten Jobs wird aktuell durch die Nutzung zweier getrennter \class{Executor}-Instanzen gelöst. Das lässt sich durch das Design des Interface \class{BlocklibExecutorService} leicht anzupassen, da dieses für die Definition von Prioritäten den Aufzählungstyp \class{TaskPriority} nutzt. \class{TaskPriority} enthält aktuell nur die Werte \const{NORMAL} und \const{BACKGROUND}, kann aber sofort erweitert werden, sobald die Implementierung des Executors mehr Prioritäten zulässt. 

Ziel für die Zukunft ist es, dass statt der durch Java bereitgestellten \class{ScheduledThreadPoolExecutor} Klasse ein vollkommen eigenständiger \class{ExecutorService} entwickelt wird, der das Interface \class{BlocklibExecutorService} implementiert. Dieser benötigt eine zweistufige Prioritäts-Warteschlange. Die erste Priorisierung ergibt sich aus den Anforderungen von \class{ScheduledExectutorService}. Danach werden die Tasks nach ihrem Zeitplan sortiert, Tasks die sofort ausgeführt werden sollen müssen vor Tasks einsortiert werden, die erst in einer Sekunde ausgeführt werden sollen. Bei Tasks, die denselben Zeitplan besitzen müssen dann nach ihrer Priorität (\class{TaskPriority}) sortiert werden. Bei gleicher Priorität kann eine beliebige Sortierung verwendet werden. Die Einfüge-Reihenfolge bietet sich aber an, sodass hinzugefügte Tasks auch zuerst ausgeführt werden (engl. first-in first-out (FIFO)).

Bei eingehenden Tasks prüft der \class{BlocklibExecutor} die Priorität und wählt danach den entsprechenden Executor aus. Dann muss der Task noch so verpackt werden, dass eine Verkettung von Tasks möglich ist.

\subsubsection{Komposition von Tasks}\label{sec:Verkettung}
Die Klasse \class{CompletableFutureWrapper} ist für die Verpackung der Tasks zuständig, sodass diese komponiert werden können. Abbildung~\ref{fig:wrapper} zeigt ein Klassendiagramm der Klassen, die für Implementierung der Möglichkeit zur Komposition von Tasks nötig sind. Der \class{CompletableFutureWrapper} instanziiert dafür die gezeigten Klassen. Diese implementieren beispielsweise das Interface \class{Callable} oder sind von \class{CompletableFuture} abgeleitet.

Die Klasse \class{CompletingCallable} enthält die übergebene \class{TaskPriority} und eine Sequenznummer für eine zukünftige Prioritäts-Warteschlange. Zudem wird bei der Konstruktion der ursprüngliche Task und ein \class{CompletableFuture}-Objekt übergeben. 
\begin{lstlisting}[caption={\code{call()}-Methode von \class{CompletingCallable}. Das enthaltene \class{Callable} wird ausgeführt und dann das \class{CompletableFuture} abgeschlossen.}, label={lst:CompletingCall},float={thbp}]
	public V call() throws Exception {
		try {
			var result = innerCallable.call(); (*\label{lst:CompletingCall:call}*)
			completableFuture.complete(result); (*\label{lst:CompletingCall:complete}*)
			return result;
		} catch (Exception e) {
			completableFuture.completeExceptionally(e); (*\label{lst:CompletingCall:exceptionally}*)
			throw e;
		}
	}
\end{lstlisting}
Wie in Listing~\ref{lst:CompletingCall} zu sehen, führt das \class{CompletingCallable} in seiner \code{call()}-Methode von die \code{call()}-Methode des ihm übergebenen \class{Callable} \var{innerCallable} aus und speichert den Rückgabewert (Zeile~\ref{lst:CompletingCall:call}). Ist der Aufruf erfolgreich, wird das übergebene \class{CompletableFuture} mit dem Rückgabewert abgeschlossen (Zeile~\ref{lst:CompletingCall:complete}). Tritt ein Fehler auf, so wird das  \class{CompletableFuture} mit dem entstandenen Fehler abgeschlossen (Zeile~\ref{lst:CompletingCall:exceptionally}).

Auf diese Weise kann das übergebene \class{CompletableFuture} genutzt werden, um nach Abschluss des inneren \class{Callable} weitere Tasks anzuhängen.
Da das Interface \class{ExecutorService} die Übergabe von \class{Callable} aber auch \class{Runnable} unterstützt, werden aus \class{Runnable}-Objekten mit der Klasse \class{RunnableCallable} in \class{Callable}-Objekte verpackt.

Die \class{CompletableFuture}-Objekte, die der Klasse \class{CompletingCallable} übergeben werden, werden ebenfalls von \class{CompletableFutureWrapper} erzeugt. Da intern für die Ausführung die von Java bereitgestellte \class{ScheduledThreadPoolExecutor}-Klasse genutzt wird, müssen bei bestimmten Methodenaufrufen \glspl{Anweisung} an die von dieser Klasse zurückgegebenen \class{Future}-Objekte delegiert werden. Daher erzeugt der 
\class{CompletableFutureWrapper} Objekte, die von \class{CompletingCallable} abgeleitet sind. Je nach \class{Executor}-Aufruf wird entweder ein Objekt der Klasse \class{DelegatingCompletableFuture} (in \code{submit(...)}-Aufrufen) oder ein \class{DelegatingScheduledCompletableFuture}-Objekt (in \code{schedule(...)}-Aufrufen) erstellt. Diese Klassen delegieren dann gegebenenfalls \glspl{Anweisung} an die ihnen übergebenen \class{Future}-Objekte.

\begin{figure}
	\centering
	\includesvg[width=.9\textwidth]{Wrapper.svg}
	\caption{Klassendiagramm von \class{CompletableFutureWrapper} und von ihm genutzten Klassen.}\label{fig:wrapper}
\end{figure}

Um diesen Vorgang besser zu verstehen, wird nun ein beispielhafter Aufruf des \class{BlocklibExecutor} skizziert. Angenommen es soll in der Blocklib ein Art Gift geben, das ein Spielercharakter zu sich nehmen kann und dann nach einer Minute etwas Leben verliert. Die hypothetisch dafür zuständige Klasse muss nun auf irgendeine Weise dafür sorgen, dass eine Minute nach der Einnahme des Gifts die \code{setHealth()}-Methode des Spielercharakters entsprechend aufgerufen wird. Dafür lässt sich nun ein Task definieren und an das Jobsystem übergeben. Dieser könnte zum Beispiel so aussehen \code{blocklibExecutor.schedule(() -> player.setHealth(player.getHealth() - 5), 1, TimeUnit.MINUTES, TaskPriority.BACKGROUND)}. Der übergebene Task besitzt keinen Rückgabewert und wird daher als \class{Runnable} interpretiert. Zudem wird die Wartezeit von einer Minute übergeben und die Priorität als auf \code{TaskPriority.BACKGROUND} gesetzt.

Die Klasse \class{BlocklibExecutor} prüft nun die Priorität und nutzt aufgrund dessen den \class{ExecutorService}, der für die Ausführung von Hintergrundtasks vorgesehen ist. Dann wird der Task an die Klasse \class{CompletableFutureWrapper} weitergegeben. Da der Task ein \class{Runnable}-Objekt ist, wird er zunächst in einem \class{RunnableCallable} verpackt. Zudem wird ein \class{DelegatingScheduledCompletableFuture}-Objekt erzeugt. Diese beiden Objekte werden dann dem Konstruktor für ein \class{CompletingCallable} übergeben. Dann wird die \code{schedule(..)}-Methode des Hintergrund-\class{ScheduledThreadPoolExecutor}-Objekts aufgerufen, die ein \class{Future}-Objekt zurückgibt. Dieses Objekt wird dann nachträglich dem \class{DelegatingScheduledCompletableFuture}-Objekt übergeben, sodass es \glspl{Anweisung} erhalten kann. Das delegierende \class{CompletableFuture}-Objekt wird dann an den Aufrufer zurückgegeben. Der ursprüngliche Task wird schlussendlich also einmal in ein \class{RunnableCallable} und dann in ein \class{CompletingCallable} verpackt. Das \class{CompletingCallable} sorgt dafür, dass das zurückgegebene \class{CompletableFuture} korrekt abgeschlossen wird und dieses ist wiederum für dafür zuständig, \glspl{Anweisung} an das interne \class{Future}-Objekt weiterzugeben.

Auf diese Art und Weise lassen sich nun die meisten Aufgaben lösen, die in der Blocklib Nebenläufigkeit nutzen. Welche \glspl{Anweisung} angepasst werden, wird im folgenden Abschnitt beschrieben.

\subsubsection{Konsolidierung mit dem bestehenden System}\label{sec:Konsolidierung}

Die Stellen, die in der Blocklib bereits Multithreading nutzen, sind bereits in der Analyse der Blocklib in Tabelle~\ref{tab:concTasksBlocklib} näher betrachtet worden. Zur Erinnerung werden diese hier noch einmal kurz aufgezählt: \class{ChunkStorage}, \class{EventManager}, \class{ConnectionInfo}, \class{NioClientNetworkLayer}, \class{NioServerNetworkLayer}, \class{Fluid} und \class{AudioManager}.

Die Bereiche, die Client-Server-Aufgaben behandeln, werden nicht konsolidiert. Das sind \class{ConnectionInfo}, \class{NioClientNetworkLayer} und \class{NioServerNetworkLayer}. Das liegt daran, dass die Aufgaben, für die hier Multithreading verwendet wird, im Gegensatz zu den anderen Bereichen konzeptuell etwas komplizierter sind. Die Threads werden für die Netzwerkkommunikation genutzt. Hier muss also genau analysiert werden, wie sich das in das Jobsystem integrieren lässt. Für Anpassungen der Klasse \class{ConnectionInfo} wird beispielsweise Wissen über das Java-Framework Spring~\cite{VMware2022} benötigt, das für die Entwicklung der Serverfunktionalität der Blocklib verwendet wird. Die Klasse wird nicht direkt mittels \code{new} instanziiert, sondern intern in Spring über die Nutzung \class{ConnectionInfo.class}. Übergabe des \class{BlocklibExecutor} an den Konstruktor ist hier ohne Wissen über das Framework also nicht möglich.

In den anderen Bereichen lässt sich der \class{BlocklibExecutorService} allerdings einfacher nutzen. Wie bereits erwähnt erhält die Klasse \class{Context} über den Konstruktor eine Instanz der Klasse \class{BlockilbExecutor}. Diese kann dann an die Klassen, die der \class{Context} instanziiert, über den Konstruktor übergeben werden. Den Konstruktoren der Klassen \class{ChunkStorage}, \class{EventManager}, \class{FluidManager}, \class{AudioManager} und der gegebenenfalls von ihnen abgeleiteten Klassen wird jeweils ein \class{BlocklibExecutorService}-Parameter hinzugefügt.

Die Anpassung der Klasse \class{ChunkStorage} gestaltet sich sehr einfach. Da diese Klasse bereit einen \class{Exectutor} genutzt hat, ändert sich das verwendete Interface nicht. Da die Generierung von Chunks im Hintergrund geschehen soll, wird lediglich zusätzlich die Priorität als \code{TaskPriority.BACKGROUND} definiert. Ansonsten würde die große Menge an Tasks, die erzeugt wird, wenn viele neue Chunks geladen werden müssen, die Simulation verzögern. Das würde dafür sorgen, dass dann starke Einbrüche der Bildwiederholrate zu bemerken wären. Die angepassten Methoden sind	\code{loadChunk(...)}, \code{saveChunk(...)}, \code{doLoadChunk(...)} und \code{meshChunk(..)}.

Auch bei der Anpassung der Klasse \class{EventManager} treten keine größeren Probleme auf. Wichtig zu beachten ist nur, dass der zuvor genutzte \class{ExecutorService} genau einen Thread genutzt hat. Das führt dazu, dass die Tasks, die \class{EventManager} übergibt, sequentiell ausgeführt werden. Das muss bei der Ausführung mittels des neuen Jobsystems beachtet werden, da sonst durch die nebenläufige Ausführung der Tasks Wettkampfbedingungen entstehen können. Hier wird also die Möglichkeit zur Verkettung von Tasks genutzt, damit Tasks gestartet werden, sobald der vorherige abgeschlossen ist. Die angepasste Methode ist \code{dispatchEvent(...)}.

Die Klasse \class{FluidManager} übergibt den \class{BlocklibExecutor} an \class{Fluid}-Objekte, deren Ausbreitungs-Simulation gestartet wird. Statt für jedes \class{Fluid}-Objekt einen eigenen Thread zu starten, der \code{sleep(...)} für die Implementierung eines Simulationsintervalls nutzt, kann nun die Methode \code{scheduleAtFixedRate(...)} verwendet werden, der ein Simulationsintervall übergeben wird. Die angepassten Methoden sind \code{Fluid.startSimulating(...)} und \code{FluidManager.add(...)}.

Im \class{AudioManager} wird der \class{Timer} ersetzt, indem die von \class{BlocklibExecutorService} definierte Methode \code{schedule(...)} mit Priorität \code{TaskPriority.BACKGROUND} verwendet wird. Da der \class{AudioManager} die Möglichkeit bietet, alle Musik zu stoppen, wird das von \code{schedule(...)} zurückgegebene \class{Future}-Objekt gespeichert, sodass gegebenenfalls die \class{Future.cancel()}-Methode aufgerufen werden kann, um zukünftige Musikausführung zu stoppen. Die angepassten Methoden sind \code{startBackgroundMusic()}, \code{stopBackgroundMusic()}, \code{playNextBgMusic()} und \code{ALDestroy()}.

Damit ist die Implementierung einer nebenläufigen Architektur in der Blocklib vorläufig abgeschlossen. Im folgenden Kapitel wird analysiert, welche Änderungen in der Performance der Blocklib sich daraus ergeben.