Bei der Implementierung des Jobsystems liegt die Aufgabe insbesondere darin, die Verkettung von Jobs durch die Nutzung von \classCompletableFuture{}-Objekten zu ermöglichen. Diese Verkettung ist nämlich die Voraussetzung dafür, dass die Simulation später Schritt für Schritt in Jobs zerlegt werden kann, die dann aufeinander aufbauen und einen Jobgraphen bilden. 

Während der Implementierung ist eine weitere Anforderung zum Vorschein gekommen, die nicht vollständig gelöst wird. Dabei handelt es sich um die in Abschnitt~\vref{sec:reqBackgroundTasks} beschriebene Anforderung, die Ausführung von Hintergrundtasks zu ermöglichen, ohne die Ausführung anderer Tasks zu blockieren. 

Den zentralen Zugriffspunkt auf das Jobsystem bietet das neu definierte Interface \classBlocklibExecutorService{}, das von der Klasse \classBlocklibExecutor{} implementiert wird. Ein gekürztes Klassendiagramm ist in Abbildung~\ref{fig:diag-BlocklibExecutor} dargestellt.

\begin{figure}[!htb]
	\centering
	\includesvg[width=\textwidth]{BlocklibExecutor-shortened.svg}
	\caption[Gekürztes Klassendiagramm von \classBlocklibExecutor{}.]{Klassendiagramm von \classBlocklibExecutor{}, das nur die \emph{nicht} von dem Interface \classBlocklibExecutorService{} definierten Attribute und Methoden zeigt.}\label{fig:diag-BlocklibExecutor}
\end{figure}

Von der Klasse \classBlocklibExecutor{} soll dauerhaft nur eine Instanz existieren, damit die Verwaltung der nebenläufigen Threads von einer Stelle aus stattfindet. Wie in Abschnitt~\vref{sec:design} erläutert kann die Nutzung global verfügbarer Objekte wie \classContext{} zu schwer nachvollziehbarem Code führen, da beispielsweise Abhängigkeiten zwischen Modulen versteckt werden. Daher wird hier nicht auf das Entwurfsmuster \gls{singleton} zurückgegriffen, sondern das in den Grundlagen beschriebene lokale Singleton-Design implementiert. Um sicherzustellen, dass von der Klasse nur eine Instanz erzeugt wird, enthält \classBlocklibExecutor{} ein statisches Attribut \var{instanced} des Typs \classAtomicBoolean{}. Beim Aufruf des Konstruktors wird mit der Methode \code{ensureUniqueInstance()} geprüft, ob bereits eine Instanz der Klasse erzeugt worden ist. Das dafür verwendete Attribut \var{instanced} besitzt den Typ \code{AtomicBoolean}, um sicherzustellen, dass diese Prüfung nicht-blockierend synchronisiert ist und damit threadsicher ist. Existiert bereits eine Instanz, wird eine \classUnsupportedOperationException{} erzeugt, die darauf hinweist.

Die Klasse \classBlocklibExecutor{} besitzt Referenzen auf zwei Instanzen von \classScheduledThreadPoolExecutor{}. Damit wird die Anforderung behelfsmäßig unterstützt, Hintergrundaufgaben zu ermöglichen. Im Gegenzug wird jedoch darauf verzichtet, die Anzahl der Java-Threads genau an die Anzahl der Hardware-Threads anzupassen. Für jeden der beiden \classScheduledThreadPoolExecutor{} werden $\text{Anzahl(Hardware-Threads)} - 1$ Java-Threads erzeugt. Damit entsteht zwar ein Wettstreit um die Belegung der Hardware-Threads, aber nur, wenn in beiden Systemen auch genügend Jobs gleichzeitig vorhanden sind. Aktuell ist das in der Regel nicht der Fall, da die Simulation noch weitgehend sequentiell als ein Job auf einem Thread ausgeführt wird und die konsolidierten Jobs sehr unregelmäßig sind. Die Konsolidierung der bereits vorhandenen Nebenläufigkeit in das Jobsystem wird in Abschnitt~\ref{sec:Konsolidierung} noch genauer erläutert. 

In den folgenden Abschnitten wird die Implementierung des Jobsystems erläutert, indem die unterschiedlichen Aufgabenbereiche jeweils näher beleuchtet werden. Zuerst wird in Abschnitt~\ref{sec:Koordinierung} beschrieben, wie die Koordinierung des Jobsystems aufgebaut ist und wie andere Module auf das Jobsystem zugreifen können. In Abschnitt~\ref{sec:Verkettung} wird beschrieben, wie das System die Komposition von Jobs ermöglicht. Zuletzt wird in Abschnitt~\ref{sec:Konsolidierung} die oben bereits erwähnte Konsolidierung von Blocklib und Jobsystem beschrieben.

\subsubsection{Koordinierung durch \texttt{BlocklibExecutor}}\label{sec:Koordinierung}

Wie bereits beschrieben dient die Klasse \classBlocklibExecutor{} als Zugriffspunktpunkt auf das neu implementierte Jobsystem, indem sie das Interface \classBlocklibExecutorService{} implementiert. Um der Bibliothek möglichst früh zur Verfügung zu stehen, wird \classBlocklibExecutor{} im Konstruktor der \classGame{}-Klasse instanziiert, die als Einstiegspunkt für die Blocklib dient. Wie Abbildung~\ref{fig:diag-BlocklibExecutor} zeigt, besitzt die Klasse \classBlocklibExecutor{} eine statische Methode \code{defaultConfig()}, die eine \classBlocklibExecutor{}-Instanz in einer Standardkonfiguration erzeugt.

Aktuell bedeutet das, dass die oben erwähnten \classScheduledThreadPoolExecutor{} erzeugt werden und jeweils $\text{Anzahl(Hardware-Threads)} - 1$ Java-Threads besitzen. Um die Threads beispielsweise beim Debugging zuordnen zu können, werden sie über die neue Klasse \classNamedThreadFactory{} erzeugt, die es ermöglicht den erzeugten Threads ein Namenspräfix zu geben. Dadurch besitzen alle Job-Threads den Namen \emph{Jobs-thread-\{x\}} und alle Hintergrund-Threads den Namen \emph{Background-thread-\{x\}}, wobei \{x\} jeweils durch eine Zahl von 1 bis $\text{Anzahl(Hardware-Threads)} - 1$ ersetzt wird.

Die in \classGame{} erzeugte \classBlocklibExecutor{}-Instanz wird dann unter anderem an den Konstruktor der \classContext{}-Klasse übergeben, die momentan für die Instanziierung der meisten Module der Blocklib verantwortlich ist. Hier wird der \classBlocklibExecutor{} an die Konstruktoren der Module übergeben, die das Jobsystem nutzen.

Die Implementierung von priorisierten Jobs wird aktuell durch die Nutzung zweier getrennter \classExecutor{}-Instanzen gelöst. Das lässt sich durch das Design des Interface \classBlocklibExecutorService{} leicht anpassen, da dieses für die Definition von Prioritäten den Aufzählungstyp \classTaskPriority{} nutzt. \classTaskPriority{} enthält aktuell nur die Werte \const{NORMAL} und \const{BACKGROUND}, kann aber sofort erweitert werden, wenn die Implementierung des \classBlocklibExecutorService{} mehr Prioritäten zulässt. 

Ziel für die Zukunft sollte es sein, dass statt der Nutzung der durch Java bereitgestellten \classScheduledThreadPoolExecutor{}-Klasse ein vollkommen eigenständiger \classExecutorService{} entwickelt wird, der das Interface \classBlocklibExecutorService{} implementiert. Dieser benötigt eine zweistufige Prioritäts-Warteschlange. Die erste Priorisierung ergibt sich aus den Anforderungen von \classScheduledExecutorService{}. Zuerst werden die Tasks nach ihrem Zeitplan sortiert. Tasks die sofort ausgeführt werden sollen, müssen vor Tasks einsortiert werden, die erst später ausgeführt werden sollen. Tasks, die denselben Zeitplan besitzen, müssen dann nach ihrer Priorität (\classTaskPriority{}) sortiert werden. Bei gleicher Priorität kann eine beliebige Sortierung verwendet werden. Die Einfüge-Reihenfolge bietet sich an, da früher hinzugefügte Tasks dann zuerst ausgeführt werden (engl. \ac{fifo}).

Bei eingehenden Tasks prüft der \classBlocklibExecutor{} die Priorität und wählt danach den entsprechenden Executor aus. Dann muss der Task noch so verarbeitet werden, dass eine Verkettung möglich ist.

\subsubsection{Komposition von Tasks}\label{sec:Verkettung}
Die Klasse \classCompletableFutureWrapper{} ist dafür zuständig, die Tasks so zu verändern, dass diese komponiert werden können. Abbildung~\ref{fig:wrapper} zeigt ein Klassendiagramm nötiger Klassen zur Implementierung der Komposition von Tasks. 

\begin{figure}[htbp]
	\centering
	\includesvg[width=.9\textwidth]{Wrapper.svg}
	\caption{Klassendiagramm von \classCompletableFutureWrapper{} und von ihm genutzter Klassen.}\label{fig:wrapper}
\end{figure}

Der \classCompletableFutureWrapper{} nutzt das \emph{Dekorierer}-Entwurfsmuster  und instanziiert dafür die gezeigten Klassen. Diese implementieren beispielsweise das Interface \classCallable{} oder sind von \classCompletableFuture{} abgeleitet. Mit dem Dekorierer-Muster lässt sich die Funktionalität einer Klasse erweitern, indem sogenannte Dekorierer(-Klassen) genutzt werden, die das selbe Interface implementieren wie die zu erweiternde Klasse. Ein Dekorierer besitzt ein Attribut des Typs des zugehörigen Interface, in diesem Fall \classCallable{} und \class(Scheduled-)Future{}. Ein zu erweiterndes Objekt wird \emph{dekoriert}, indem es einem Dekorierer-Objekt übergeben wird. Dann kann das Dekorierer-Objekt anstelle des dekorierten Objekts verwendet werden und gegebenenfalls Methodenaufrufe an das dekorierte Objekt weiterleiten, auch delegieren genannt.


Die Klasse \classCompletingCallable{} ist ein Dekorierer für \classCallable{}-Objekte. Sie enthält neben dem dekorierten Task \var{innerCallable} ein Attribut des Typs \classTaskPriority{} und eine Sequenz-Nummer für eine zukünftige Prioritäts-Warteschlange. Zudem wird ein \classCompletableFuture{}-Objekt übergeben, das abhängig von der Ausführung abgeschlossen wird. Wie in Listing~\ref{lst:CompletingCall} zu sehen, führt das \classCompletingCallable{} innerhalb der eigenen \tcode{call()}-Methode die \tcode{call()}-Methode des ihm übergebenen \classCallable{} \var{innerCallable} aus und speichert den Rückgabewert (Zeile~\ref{lst:CompletingCall:call}). Ist der Aufruf erfolgreich, wird das übergebene \classCompletableFuture{} mit dem Rückgabewert abgeschlossen (Zeile~\ref{lst:CompletingCall:complete}). Tritt ein Fehler auf, so wird das  \classCompletableFuture{} mit dem entstandenen Fehler abgeschlossen (Zeile~\ref{lst:CompletingCall:exceptionally}).

\begin{lstlisting}[caption={\tcode{call()}-Methode von \classCompletingCallable{}. Das enthaltene \classCallable{} wird ausgeführt und dann das \classCompletableFuture{} abgeschlossen.}, label={lst:CompletingCall},float={thbp}]
	public V call() throws Exception {
		try {
			var result = innerCallable.call(); (*\label{lst:CompletingCall:call}*)
			completableFuture.complete(result); (*\label{lst:CompletingCall:complete}*)
			return result;
		} catch (Exception e) {
			completableFuture.completeExceptionally(e); (*\label{lst:CompletingCall:exceptionally}*)
			throw e;
		}
	}
\end{lstlisting}


Auf diese Weise kann das übergebene \classCompletableFuture{} genutzt werden, um nach Abschluss des inneren \classCallable{} weitere Tasks anzuhängen.
Da das Interface \classExecutorService{} die Übergabe von \classRunnable{} aber auch \classCallable{} unterstützt, werden \classRunnable{}-Objekte mit der Klasse \classRunnableCallable{} als \classCallable{}-Objekte dekoriert.  

Die \classCompletableFuture{}-Objekte, die der Klasse \classCompletingCallable{} übergeben werden, werden ebenfalls von \classCompletableFutureWrapper{} erzeugt. Da intern für die Ausführung die von Java bereitgestellte \classScheduledThreadPoolExecutor{}-Klasse genutzt wird, müssen bei bestimmten Methodenaufrufen \glspl{Anweisung} an die von dieser Klasse zurückgegebenen \classFuture{}-Objekte delegiert werden. Aus diesem Grund erzeugt der 
\classCompletableFutureWrapper{} Objekte, die von \classCompletableFuture{} abgeleitet sind. Je nach \classExecutor{}-Aufruf wird entweder ein Objekt der Klasse \classDelegatingCompletableFuture{} (in \tcode{submit(...)}-Aufrufen) oder ein \classDelegatingScheduledCompletableFuture{}-Objekt (in \tcode{schedule(...)}-Aufrufen) erstellt. Diese Klassen delegieren dann gegebenenfalls \glspl{Anweisung} an die ihnen übergebenen \classFuture{}-Objekte. Um diesen Vorgang besser zu verstehen, wird nun ein beispielhafter Aufruf des \classBlocklibExecutor{} skizziert.

\begin{example}
	Angenommen es soll in der Blocklib ein Gift implementiert werden, das ein Spielercharakter zu sich nehmen kann und dann nach einer Minute fünf Lebenspunkte verliert. Die dafür zuständige Klasse muss nun dafür sorgen, dass eine Minute nach der Einnahme des Gifts die \tcode{setHealth()}-Methode des Spielercharakters entsprechend aufgerufen wird. Dafür lässt sich nun ein Task definieren und an das Jobsystem übergeben. Dieser könnte zum Beispiel so aussehen: \tcode{blocklibExecutor.schedule(() -> player.setHealth(player.getHealth() - 5), 1, TimeUnit.MINUTES, TaskPriority.BACKGROUND)}. Der übergebene Task besitzt keinen Rückgabewert und wird somit als \classRunnable{} interpretiert. Zudem wird die Wartezeit von einer Minute übergeben und die Priorität auf \tcode{TaskPriority.BACKGROUND} gesetzt.

	Die Klasse \classBlocklibExecutor{} prüft nun die Priorität und nutzt aufgrund dessen den \classExecutorService{}, der für die Ausführung von Hintergrundtasks vorgesehen ist. Dann wird der Task an die Klasse \classCompletableFutureWrapper{} weitergegeben. Da der Task ein \classRunnable{}-Objekt ist, wird er zunächst mit einem \classRunnableCallable{} dekoriert. Zudem wird ein \classDelegatingScheduledCompletableFuture{}-Objekt erzeugt. Diese beiden Objekte werden dann dem Konstruktor für ein \classCompletingCallable{} übergeben. Dann wird die \code{schedule(..)}-Methode des Hintergrund-\classScheduledThreadPoolExecutor{}-Objekts aufgerufen, die ein \classFuture{}-Objekt zurückgibt. Dieses Objekt wird dann nachträglich dem \classDelegatingScheduledCompletableFuture{}-Objekt übergeben, sodass es \glspl{Anweisung} erhalten kann. Das delegierende \classCompletableFuture{}-Objekt wird dann an den Aufrufer zurückgegeben. Der ursprüngliche Gift-Task wird schlussendlich also einmal mit einem \classRunnableCallable{} und dann mit einem \classCompletingCallable{} dekoriert. Das \classCompletingCallable{} sorgt dafür, dass das zurückgegebene \classCompletableFuture{} korrekt abgeschlossen wird und dieses ist wiederum dafür zuständig, \glspl{Anweisung} an das interne \classFuture{}-Objekt weiterzugeben.
\end{example}

Auf diese Art und Weise lassen sich die meisten Aufgaben lösen, die in der Blocklib Nebenläufigkeit nutzen. Welche \glspl{Anweisung} angepasst werden, wird im folgenden Abschnitt beschrieben.

\subsubsection{Konsolidierung mit dem bestehenden System}\label{sec:Konsolidierung}

Die Stellen, die in der Blocklib bereits Multithreading nutzen, sind schon in der Analyse der Blocklib in Tabelle~\ref{tab:concTasksBlocklib} näher betrachtet worden. Zur Erinnerung werden diese hier noch einmal aufgezählt: \classChunkStorage{}, \classEventManager{}, \classConnectionInfo{}, \classNioClientNetworkLayer{}, \classNioServerNetworkLayer{}, \classFluid{} und \classAudioManager{}.

Die Bereiche, die Client-Server-Aufgaben behandeln, werden nicht konsolidiert. Das sind die Klassen \classConnectionInfo{}, \classNioClientNetworkLayer{} und \classNioServerNetworkLayer{}. Das liegt daran, dass die Aufgaben, für die hier Multithreading verwendet wird, im Gegensatz zu den anderen Bereichen konzeptionell etwas komplizierter sind. Die Threads werden für die Netzwerkkommunikation genutzt. Hier muss also genau analysiert werden, wie sich die Thread-Nutzung dieser Klassen in das Jobsystem integrieren lassen. Für Anpassungen der Klasse \classConnectionInfo{} wird beispielsweise Wissen über das Java-Framework Spring~\cite{VMware2022} benötigt, das für die Entwicklung der Serverfunktionalität der Blocklib verwendet wird. Die Klasse wird nicht direkt mittels \code{new} instanziiert, sondern intern in Spring über die Nutzung des Klassen-Objekts \classConnectionInfo.class{}. Eine Übergabe des \classBlocklibExecutor{} an den Konstruktor ist hier ohne Wissen über das Framework also nicht möglich.

In den anderen Bereichen lässt sich der \classBlocklibExecutorService{} allerdings einfacher nutzen. Wie bereits erwähnt, erhält die Klasse \classContext{} über den Konstruktor eine Instanz der Klasse \classBlocklibExecutor{}. Diese kann wiederum über Konstruktoren an die Klassen übergeben werden, die der \classContext{} instanziiert. Daher wird den Konstruktoren der Klassen \classChunkStorage{}, \classEventManager{}, \classFluidManager{}, \classAudioManager{} und der gegebenenfalls von ihnen abgeleiteten Klassen jeweils ein \classBlocklibExecutorService{}-Parameter hinzugefügt.

Die Anpassung der Klasse \classChunkStorage{} gestaltet sich sehr einfach. Da diese Klasse bereits einen \classExecutor{} nutzt, ändert sich das verwendete Interface nicht. Da die Generierung von Chunks im Hintergrund geschehen soll, wird lediglich zusätzlich die Priorität als \tcode{TaskPriority.BACKGROUND} definiert. Ansonsten würde die große Menge an Tasks, die erzeugt werden, wenn viele neue Chunks geladen werden müssen, die Simulation verzögern und es wären starke Einbrüche der Bildwiederholrate zu bemerken. Die angepassten Methoden sind	\tcode{loadChunk(...)}, \tcode{saveChunk(...)}, \tcode{doLoadChunk(...)} und \tcode{meshChunk(..)}.

Auch bei der Anpassung der Klasse \classEventManager{} treten keine größeren Probleme auf. Es ist jedoch wichtig zu beachten, dass der zuvor genutzte \classExecutorService{} genau einen Thread genutzt hat. Das führt dazu, dass die Tasks, die der \classEventManager{} übergibt, sequentiell ausgeführt werden. Das muss bei der Ausführung mittels des neuen Jobsystems beachtet werden, da sonst durch die nebenläufige Ausführung der Tasks Wettkampfbedingungen entstehen können. Hier wird also die Möglichkeit zur Verkettung von Tasks genutzt, damit Tasks gestartet werden, sobald der vorherige abgeschlossen ist. Die angepasste Methode ist \tcode{dispatchEvent(...)}.

Die Klasse \classFluidManager{} übergibt den \classBlocklibExecutor{} an \classFluid{}-Objekte, deren Aus\-brei\-tungs-Si\-mu\-la\-ti\-on gestartet wird. Statt für jedes \classFluid{}-Objekt einen eigenen Thread zu starten, der \tcode{sleep(...)} für die Implementierung eines Simulationsintervalls nutzt, kann nun die Methode \tcode{scheduleAtFixedRate(...)} verwendet werden, der ein Simulationsintervall übergeben wird. Die geänderten Methoden sind \tcode{Fluid.startSimulating(...)} und \tcode{FluidManager.add(...)}.

Im \classAudioManager{} wird der \classTimer{} ersetzt, indem die von \classBlocklibExecutorService{} definierte Methode \tcode{schedule(...)} mit Priorität \tcode{TaskPriority.BACKGROUND} verwendet wird. Da der \classAudioManager{} die Möglichkeit bietet, das Abspielen von Hintegrundmusik zu stoppen, wird das von \tcode{schedule(...)} zurückgegebene \classFuture{}-Objekt gespeichert. So kann gegebenenfalls dessen \code{cancel()}-Methode aufgerufen werden, um geplante Musikausführung zu stoppen. Die angepassten Methoden sind \tcode{startBackgroundMusic()}, \tcode{stopBackgroundMusic()}, \tcode{playNextBgMusic()} und \tcode{ALDestroy()}.

Damit ist die Implementierung einer nebenläufigen Architektur in der Blocklib vorläufig abgeschlossen. Im folgenden Kapitel wird analysiert, welche Änderungen sich daraus in der Leistung der Blocklib ergeben.