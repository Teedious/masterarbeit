Bei der Implementierung des Jobsystems liegt die Aufgabe insbesondere darin, die Verkettung von Jobs durch \class{CompletableFuture} zu ermöglichen. Diese Verkettung ist nämlich die Voraussetzung dafür, dass die Simulation später Schritt für Schritt in Jobs zerlegt werden kann, die dann aufeinander aufbauen und einen Jobgraphen bilden. 

Während der Implementierung ist eine weitere Anforderung zum Vorschein gekommen, die aufgrund des Zeitpunkts, zu dem sie aufgetaucht ist, nicht vollständig gelöst ist. Dabei handelt es sich um die in Abschnitt~\ref{sec:reqBackgroundTasks} beschriebene Anforderung, die Ausführung von Hintergrundtasks zu ermöglichen, ohne die Ausführung anderer Tasks zu blockieren. 

Den Zugriffspunkt auf das Jobsystem bietet das neu definierte Interface \class{BlocklibExecutorService}, das von der Klasse \class{BlocklibExecutor} implementiert wird. Ein gekürztes Klassendiagramm ist in Abbildung~\vref{fig:diag-BlocklibExecutor} dargestellt.

\begin{figure}[!htb]
	\centering
	\includesvg[width=\textwidth]{BlocklibExecutor-shortened.svg}
	\caption{Klassendiagramm von \class{BlocklibExecutor}, das nur die \emph{nicht} von dem Interface \class{BlocklibExecutorService} definierten Attribute und Methoden zeigt.}\label{fig:diag-BlocklibExecutor}
\end{figure}

Von der Klasse \class{BlocklibExecutor} soll dauerhaft nur eine Instanz existieren, damit die Verwaltung der nebenläufigen Threads von einer Stelle aus stattfinden. Es steht in Aussicht, dass die Nutzung globaler Objekte wie \class{Context} in Zukunft verringert wird. Das wird noch genauer im Ausblick in Abschnitt~\vref{sec:EtablierungEinerKompositionroot} erläutert. Daher wird bei hier nicht auf das Designpattern \gls{singleton} zurückgegriffen sondern das in den Grundlagen beschriebene lokale Singleton-Design implementiert. Um sicherzustellen, dass von der Klasse nur eine Instanz erzeugt wird, enthält \class{BlocklibExecutor} ein statisches Attribut \var{instanced: AtomicBoolean}. Beim Aufruf des Konstruktors wird mit der Methode \code{ensureUniqueInstance()} geprüft, ob bereits eine Instanz der Klasse erzeugt worden ist. \var{instanced} besitzt den Typ \code{AtomicBoolean}, um sicherzustellen, dass diese Prüfung nicht-blockierend synchronisiert ist. Existiert bereits eine Instanz, wird eine \class{UnsupportedOperationException} geworfen, die darauf hinweist.

Die Klasse besitzt Referenzen auf zwei Instanzen von \class{ScheduledThreadPoolExecutor}. Damit wird die Anforderung, unterschiedliche Prioritäten von Jobs zu unterstützen behelfsmäßig unterstützt. Im Gegenzug wird jedoch darauf verzichtet, die Anzahl der Java Threads genau an die Anzahl der Hardwarethreads anzupassen. Für jeden der beiden \class{ScheduledThreadPoolExecutor} werden $\text{Anzahl(Hardwarethreads)} - 1$ Java-Threads erzeugt. Damit entsteht zwar ein Wettstreit um die Belegung der Hardwarethreads, aber nur, wenn in beiden Systemen auch genügend Jobs gleichzeitig vorhanden sind. Aktuell ist das in der Regel nicht der Fall, da die Simulation noch weitgehend sequentiell als ein Job auf einem Thread ausgeführt wird und die konsolidierten Jobs sehr unregelmäßig sind. Die Konsolidierung der bereits vorhandenen Nebenläufigkeit in das Jobsystem wird in Abschnitt~\ref{sec:Konsolidierung} noch genauer erläutert. 

In den folgenden Abschnitten wird die Implementierung des Jobsystems erläutert indem die unterschiedlichen Aufgabenbereich jeweils näher beleuchtet werden. Zuerst wird in Abschnitt~\ref{sec:Koordinierung} näher beschrieben, wie die Koordinierung das Jobsystems aufgebaut ist und wie andere Module auf das Jobsystem zugreifen können. In Abschnitt~\ref{sec:Verkettung} wird beschrieben, wie das System die Komposition von Jobs ermöglicht. Zuletzt wird in Abschnitt~\ref{sec:Konsolidierung} die oben bereits erwähnte Konsolidierung von Blocklib und Jobsystem beschrieben.

\subsubsection{Koordinierung durch \texttt{BlocklibExecutor}}\label{sec:Koordinierung}

Wie bereits beschrieben dient die Klasse \class{BlocklibExecutor} als Zugriffspunktpunkt auf das neu implementierte Jobsystem, indem sie das Interface \class{BlocklibExecutorService} implementiert. Um der Bibliothek möglichst früh zur Verfügung zu stehen, wird \class{BlocklibExecutor} im Konstruktor der \class{Game}-Klasse instanziiert, die als Einstiegspunkt für die Blocklib dient. Wie die Abbildung~\vref{fig:diag-BlocklibExecutor} zeigt, besitzt die Klasse \class{BlocklibExecutor} eine statische Methode \code{defaultConfig()}, die eine \class{BlocklibExecutor}-Instanz in einer Standardkonfiguration erzeugt.

Aktuell bedeutet das, dass die oben erwähnten \class{ScheduledThreadPoolExecutor} erzeugt werden und jeweils $\text{Anzahl(Hardwarethreads)} - 1$ Java-Threads besitzen. Um die Threads beispielsweise beim Debugging zuordnen zu können, werden die Threads über die neue Klasse \class{NamedThreadFactory} erzeugt, die es ermöglicht den erzeugten Threads ein Namenspräfix zu geben. Dadurch besitzen alle Job-Threads den Namen \emph{Jobs-thread-\{x\}} und alle Hintergrund-Threads den Namen \emph{Background-thread-\{x\}}, wobei \{x\} jeweils durch eine Zahl von 1 bis $\text{Anzahl(Hardwarethreads)} - 1$ ersetzt wird.

Die in \class{Game} erzeugte \class{BlocklibExecutor}-Instanz wird dann unter anderem an den Konstruktor der \class{Context}-Klasse übergeben, die momentan für die Instanziierung der meisten Module der Blocklib verantwortlich ist. Hier wird der \class{BlocklibExecutor} an die Konstruktoren der Module übergeben, die das Jobsystem nutzen.

Die Implementierung von priorisierten Jobs wird aktuell durch die Nutzung zweier getrennter \class{Executor}-Instanzen gelöst. Das lässt sich durch das Design des Interface \class{BlocklibExecutorService} leicht anzupassen, da dieses für die Definition von Prioritäten den Aufzählungstyp \class{TaskPriority} nutzt. \class{TaskPriority} enthält aktuell nur die Werte \const{NORMAL} und \const{BACKGROUND}, kann aber sofort erweitert werden, sobald die Implementierung des Executors mehr Prioritäten zulässt. 

Ziel für die Zukunft ist es, dass statt der durch Java bereitgestellten \class{ScheduledThreadPoolExecutor} Klasse ein vollkommen eigenständiger \class{ExecutorService} entwickelt wird, der das Interface \class{BlocklibExecutorService} implementiert. Dieser benötigt eine zweistufige Prioritäts-Warteschlange. Die erste Priorisierung ergibt sich aus den Anforderungen von \class{ScheduledExectutorService}. Danach werden die Tasks nach ihrem Zeitplan sortiert, Tasks die sofort ausgeführt werden sollen müssen vor Tasks einsortiert werden, die erst in einer Sekunde ausgeführt werden sollen. Bei Tasks, die den selben Zeitplan besitzen müssen dann nach ihrer Priorität (\class{TaskPriority}) sortiert werden. Bei gleicher Priorität kann eine beliebige Sortierung verwendet werden. Die Einfüge-Reihenfolge bietet sich aber an, sodass hinzugefügte Tasks auch zuerst ausgeführt werden (engl. first-in first-out (FIFO)).

Bei eingehenden Tasks prüft der \class{BlocklibExecutor} die Priorität und wählt danach den entsprechenden Executor aus. Dann muss der Task noch so verpackt werden, dass eine Verkettung von Tasks möglich ist.

\subsubsection{Komposition von Tasks}\label{sec:Verkettung}
Für die Verpackung von Tasks, sodass diese komponiert werden können, ist die Klasse \class{CompletableFutureWrapper} zuständig. Wie in Abbildung~\vref{fig:wrapper} gezeigt, erzeugt die Klasse dafür Klassen, die \class{Callable} implementieren und Klassen, die von \class{CompletableFuture} abgeleitet sind.
\begin{figure}
	\centering
	\includesvg[width=.9\textwidth]{Wrapper.svg}
	\caption{}\label{fig:wrapper}
\end{figure}
Die Klasse \class{CompletingCallable} enthält die übergebene \class{TaskPriority} und eine Sequenznummer für eine zukünftige Prioritäts-Warteschlange. Zudem wird bei der Konstruktion der ursprüngliche Task und ein \class{CompletableFuture}-Objekt übergeben. 
\begin{lstlisting}[caption={\code{call()}-Methode von \class{CompletingCallable}. Das enthaltene \class{Callable} wird ausgeführt und dann das \class{CompletableFuture} abgeschlossen.}, label={lst:CompletingCall},float]
	public V call() throws Exception {
		try {
			var result = innerCallable.call(); (*\label{lst:CompletingCall:call}*)
			completableFuture.complete(result); (*\label{lst:CompletingCall:complete}*)
			return result;
		} catch (Exception e) {
			completableFuture.completeExceptionally(e); (*\label{lst:CompletingCall:exceptionally}*)
			throw e;
		}
	}
\end{lstlisting}
Wie in Listing~\vref{lst:CompletingCall} zu sehen, führt das \class{CompletingCallable} in seiner \code{call()}-Methode von die \code{call()}-Methode des ihm übergebenen \class{Callable} \var{innerCallable} aus und speichert den Rückgabewert (Zeile~\ref{lst:CompletingCall:call}). Ist der Aufruf erfolgreich, wird das übergebene \class{CompletableFuture} mit dem Rückgabewert abgeschlossen (Zeile~\ref{lst:CompletingCall:complete}). Tritt ein Fehler auf, so wird das  \class{CompletableFuture} mit dem entstandenen Fehler abgeschlossen (Zeile~\ref{lst:CompletingCall:exceptionally}).

Auf diese Weise kann das übergebene \class{CompletableFuture} genutzt werden, um nach Abschluss des inneren \class{Callable} weitere Tasks anzuhängen.
Da das Interface \class{ExecutorService} die Übergabe von \class{Callable} aber auch \class{Runnable} unterstützt, werden aus \class{Runnable}-Objekten mit der Klasse \class{RunnableCallable} in \class{Callable}-Objekte verpackt.

\subsubsection{Konsolidierung mit dem bestehenden System}\label{sec:Konsolidierung}

