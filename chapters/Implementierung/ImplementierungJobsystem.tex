Bei der Implementierung des Jobsystems liegt die Aufgabe insbesondere darin, die Verkettung von Jobs durch \class{CompletableFuture} zu ermöglichen. Diese Verkettung ist nämlich die Voraussetzung dafür, dass die Simulation später Schritt für Schritt in Jobs zerlegt werden kann, die dann aufeinander aufbauen und einen Jobgraphen bilden. 

Während der Implementierung ist eine weitere Anforderung zum Vorschein gekommen, die aufgrund des Zeitpunkts, zu dem sie aufgetaucht ist, nicht vollständig gelöst ist. Dabei handelt es sich um die in Abschnitt~\ref{sec:reqBackgroundTasks} beschriebene Anforderung, die Ausführung von Hintergrundtasks zu ermöglichen, ohne die Ausführung anderer Tasks zu blockieren. 

Den Zugriffspunkt auf das Jobsystem bietet das neu definierte Interface \class{BlocklibExecutorService}, das von der Klasse \class{BlocklibExecutor} implementiert wird. Ein gekürztes Klassendiagramm ist in Abbildung~\vref{fig:diag-BlocklibExecutor} dargestellt.

\begin{figure}[!htb]
	\centering
	\includesvg[width=\textwidth]{BlocklibExecutor-shortened.svg}
	\caption{Klassendiagramm von \class{BlocklibExecutor}, das nur die \emph{nicht} von dem Interface \class{BlocklibExecutorService} definierten Attribute und Methoden zeigt.}\label{fig:diag-BlocklibExecutor}
\end{figure}

Von der Klasse \class{BlocklibExecutor} soll dauerhaft nur eine Instanz existieren, damit die Verwaltung der nebenläufigen Threads von einer Stelle aus stattfinden. Es steht in Aussicht, dass die Nutzung globaler Objekte wie \class{Context} in Zukunft verringert wird. Das wird noch genauer im Ausblick in Abschnitt~\vref{sec:EtablierungEinerKompositionroot} erläutert. Daher wird bei hier nicht auf das Designpattern \gls{singleton} zurückgegriffen sondern das in den Grundlagen beschriebene lokale Singleton-Design implementiert. Um sicherzustellen, dass von der Klasse nur eine Instanz erzeugt wird, enthält \class{BlocklibExecutor} ein statisches Attribut \var{instanced: AtomicBoolean}. Beim Aufruf des Konstruktors wird mit der Methode \code{ensureUniqueInstance()} geprüft, ob bereits eine Instanz der Klasse erzeugt worden ist. \var{instanced} besitzt den Typ \code{AtomicBoolean}, um sicherzustellen, dass diese Prüfung nicht-blockierend synchronisiert ist. Existiert bereits eine Instanz, wird eine \class{UnsupportedOperationException} geworfen, die darauf hinweist.

Die Klasse besitzt Referenzen auf zwei Instanzen von \class{ScheduledThreadPoolExecutor}. Damit wird die Anforderung, unterschiedliche Prioritäten von Jobs zu unterstützen behelfsmäßig unterstützt. Im Gegenzug wird jedoch darauf verzichtet, die Anzahl der Java Threads genau an die Anzahl der Hardwarethreads anzupassen. Für jeden der beiden \class{ScheduledThreadPoolExecutor} werden $\text{Anzahl(Hardwarethreads)} - 1$ Java-Threads erzeugt. Damit entsteht zwar ein Wettstreit um die Belegung der Hardwarethreads, aber nur, wenn in beiden Systemen auch genügend Jobs gleichzeitig vorhanden sind. Aktuell ist das in der Regel nicht der Fall, da die Simulation noch weitgehend sequentiell als ein Job auf einem Thread ausgeführt wird und die konsolidierten Jobs sehr unregelmäßig sind. Die Konsolidierung der bereits vorhandenen Nebenläufigkeit in das Jobsystem wird in Abschnitt~\ref{sec:Konsolidierung} noch genauer erläutert. 

In den folgenden Abschnitten wird die Implementierung des Jobsystems erläutert indem die unterschiedlichen Aufgabenbereich jeweils näher beleuchtet werden. Zuerst wird in Abschnitt~\ref{sec:Koordinierung} näher beschrieben, wie die Koordinierung das Jobsystems aufgebaut ist und wie andere Module auf das Jobsystem zugreifen können. In Abschnitt~\ref{sec:Verkettung} wird beschrieben, wie das System die Komposition von Jobs ermöglicht. Zuletzt wird in Abschnitt~\ref{sec:Konsolidierung} die oben bereits erwähnte Konsolidierung von Blocklib und Jobsystem beschrieben.

\subsubsection{Koordinierung durch \texttt{BlocklibExecutor}}\label{sec:Koordinierung}

Wie bereits beschrieben dient die Klasse \class{BlocklibExecutor} als Zugriffspunktpunkt auf das neu implementierte Jobsystem, indem sie das Interface \class{BlocklibExecutorService} implementiert. Um der Bibliothek möglichst früh zur Verfügung zu stehen, wird \class{BlocklibExecutor} im Konstruktor der \class{Game}-Klasse instanziiert, die als Einstiegspunkt für die Blocklib dient. Wie die Abbildung~\vref{fig:diag-BlocklibExecutor} zeigt, besitzt die Klasse \class{BlocklibExecutor} eine statische Methode \code{defaultConfig()}, die eine \class{BlocklibExecutor}-Instanz in einer Standardkonfiguration erzeugt.

Aktuell bedeutet das, dass die oben erwähnten \class{ScheduledThreadPoolExecutor} erzeugt werden und jeweils $\text{Anzahl(Hardwarethreads)} - 1$ Java-Threads besitzen. Um die Threads beispielsweise beim Debugging zuordnen zu können, werden die Threads über die neue Klasse \class{NamedThreadFactory} erzeugt, die es ermöglicht den erzeugten Threads ein Namenspräfix zu geben. Dadurch besitzen alle Job-Threads den Namen \emph{Jobs-thread-\{x\}} und alle Hintergrund-Threads den Namen \emph{Background-thread-\{x\}}, wobei \{x\} jeweils durch eine Zahl von 1 bis $\text{Anzahl(Hardwarethreads)} - 1$ ersetzt wird.

Die in \class{Game} erzeugte \class{BlocklibExecutor}-Instanz wird dann unter anderem an den Konstruktor der \class{Context}-Klasse übergeben, die momentan für die Instanziierung der meisten Module der Blocklib verantwortlich ist. Hier wird der \class{BlocklibExecutor} an die Konstruktoren der Module übergeben, die das Jobsystem nutzen.

Die Implementierung von priorisierten Jobs wird aktuell durch die Nutzung zweier getrennter \class{Executor}-Instanzen gelöst. Das lässt sich durch das Design des Interface \class{BlocklibExecutorService} leicht anzupassen, da dieses für die Definition von Prioritäten den Aufzählungstyp \class{TaskPriority} nutzt. \class{TaskPriority} enthält aktuell nur die Werte \const{NORMAL} und \const{BACKGROUND}, kann aber sofort erweitert werden, sobald die Implementierung des Executors mehr Prioritäten zulässt. 

Ziel für die Zukunft ist es, dass statt der durch Java bereitgestellten \class{ScheduledThreadPoolExecutor} Klasse ein vollkommen eigenständiger \class{ExecutorService} entwickelt wird, der das Interface \class{BlocklibExecutorService} implementiert. Dieser benötigt eine zweistufige Prioritäts-Warteschlange. Die erste Priorisierung ergibt sich aus den Anforderungen von \class{ScheduledExectutorService}. Danach werden die Tasks nach ihrem Zeitplan sortiert, Tasks die sofort ausgeführt werden sollen müssen vor Tasks einsortiert werden, die erst in einer Sekunde ausgeführt werden sollen. Bei Tasks, die den selben Zeitplan besitzen müssen dann nach ihrer Priorität (\class{TaskPriority}) sortiert werden. Bei gleicher Priorität kann eine beliebige Sortierung verwendet werden. Die Einfüge-Reihenfolge bietet sich aber an, sodass hinzugefügte Tasks auch zuerst ausgeführt werden (engl. first-in first-out (FIFO)).

Bei eingehenden Tasks prüft der \class{BlocklibExecutor} die Priorität und wählt danach den entsprechenden Executor aus. Dann muss der Task noch so verpackt werden, dass eine Verkettung von Tasks möglich ist.

\subsubsection{Komposition von Tasks}\label{sec:Verkettung}
Die Klasse \class{CompletableFutureWrapper} ist für die Verpackung der Tasks zuständig, sodass diese komponiert werden können. Abbildung~\vref{fig:wrapper} zeigt ein Klassendiagramm der Klassen, die für Implementierung der Möglichkeit zur Komposition von Tasks nötig sind. Der \class{CompletableFutureWrapper} instanziiert dafür die gezeigten Klassen. Diese implementieren beispielsweise das Interface \class{Callable} oder sind von \class{CompletableFuture} abgeleitet.

Die Klasse \class{CompletingCallable} enthält die übergebene \class{TaskPriority} und eine Sequenznummer für eine zukünftige Prioritäts-Warteschlange. Zudem wird bei der Konstruktion der ursprüngliche Task und ein \class{CompletableFuture}-Objekt übergeben. 
\begin{lstlisting}[caption={\code{call()}-Methode von \class{CompletingCallable}. Das enthaltene \class{Callable} wird ausgeführt und dann das \class{CompletableFuture} abgeschlossen.}, label={lst:CompletingCall},float]
	public V call() throws Exception {
		try {
			var result = innerCallable.call(); (*\label{lst:CompletingCall:call}*)
			completableFuture.complete(result); (*\label{lst:CompletingCall:complete}*)
			return result;
		} catch (Exception e) {
			completableFuture.completeExceptionally(e); (*\label{lst:CompletingCall:exceptionally}*)
			throw e;
		}
	}
\end{lstlisting}
Wie in Listing~\vref{lst:CompletingCall} zu sehen, führt das \class{CompletingCallable} in seiner \code{call()}-Methode von die \code{call()}-Methode des ihm übergebenen \class{Callable} \var{innerCallable} aus und speichert den Rückgabewert (Zeile~\ref{lst:CompletingCall:call}). Ist der Aufruf erfolgreich, wird das übergebene \class{CompletableFuture} mit dem Rückgabewert abgeschlossen (Zeile~\ref{lst:CompletingCall:complete}). Tritt ein Fehler auf, so wird das  \class{CompletableFuture} mit dem entstandenen Fehler abgeschlossen (Zeile~\ref{lst:CompletingCall:exceptionally}).

Auf diese Weise kann das übergebene \class{CompletableFuture} genutzt werden, um nach Abschluss des inneren \class{Callable} weitere Tasks anzuhängen.
Da das Interface \class{ExecutorService} die Übergabe von \class{Callable} aber auch \class{Runnable} unterstützt, werden aus \class{Runnable}-Objekten mit der Klasse \class{RunnableCallable} in \class{Callable}-Objekte verpackt.

Die \class{CompletableFuture}-Objekte, die der Klasse \class{CompletingCallable} übergeben werden, werden ebenfalls von \class{CompletableFutureWrapper} erzeugt.Da intern für die Ausführung die von Java bereitgestellte \class{ScheduledThreadPoolExecutor}-Klasse genutzt wird, müssen bei bestimmten Methodenaufrufen Anweisungen an die von dieser Klasse zurückgegebenen \class{Future}-Objekte delegiert werden. Daher erzeugt der 
\class{CompletableFutureWrapper} Objekte, die von \class{CompletingCallable} abgeleitet sind. Je nach \class{Executor}-Aufruf wird entweder ein Objekt der Klasse \class{DelegatingCompletableFuture} (in \code{submit(...)}-Aufrufen) oder ein \class{DelegatingScheduledCompletableFuture}-Objekt (in \code{schedule(...)}-Aufrufen) erstellt. Diese Klassen delegieren dann gegebenenfalls Anweisungen an die ihnen übergebenen \class{Future}-Objekte.

\begin{figure}
	\centering
	\includesvg[width=.9\textwidth]{Wrapper.svg}
	\caption{}\label{fig:wrapper}
\end{figure}

Um diesen Vorgang besser zu verstehen, wird nun ein beispielhafter Aufruf des \class{BlocklibExecutor} skizziert. Angenommen es soll in der Blocklib ein Art Gift geben, das ein Spielercharakter zu sich nehmen kann und dann nach einer Minute etwas Leben verliert. Die hypothetisch dafür zuständige Klasse muss nun auf irgendeine Weise dafür sorgen, dass eine Minute nach der Einnahme des Gifts die \code{setHealth()}-Methode des Spielercharakters entsprechend aufgerufen wird. Dafür lässt sich nun ein Task definieren und an das Jobsystem übergeben. Dieser könnte zum Beispiel so aussehen \code{blocklibExecutor.schedule(() -> player.setHealth(player.getHealth() - 5), 1, TimeUnit.MINUTES, TaskPriority.BACKGROUND)}. Der übergebene Task besitzt keinen Rückgabewert und wird daher als \class{Runnable} interpretiert. Zudem wird die Wartezeit von einer Minute übergeben und die Priorität als auf \code{TaskPriority.BACKGROUND} gesetzt.

Die Klasse \class{BlocklibExecutor} prüft nun die Priorität und nutzt aufgrund dessen den \class{ExecutorService}, der für die Ausführung von Hintergrundtasks vorgesehen ist. Dann wird der Task an die Klasse \class{CompletableFutureWrapper} weitergegeben. Da der Task ein \class{Runnable}-Objekt ist, wird er zunächst in einem \class{RunnableCallable} verpackt. Zudem wird ein \class{DelegatingScheduledCompletableFuture}-Objekt erzeugt. Diese beiden Objekte werden dann dem Konstruktor für ein \class{CompletingCallable} übergeben. Dann wird die \code{schedule(..)}-Methode des Hintergrund-\class{ScheduledThreadPoolExecutor}-Objekts aufgerufen, die ein \class{Future}-Objekt zurückgibt. Dieses Objekt wird dann nachträglich dem \class{DelegatingScheduledCompletableFuture}-Objekt übergeben, sodass es Anweisungen erhalten kann. Das delegierende \class{CompletableFuture}-Objekt wird dann an den Aufrufer zurückgegeben. Der ursprüngliche Task wird schlussendlich also einmal in ein \class{RunnableCallable} und dann in ein \class{CompletingCallable} verpackt. Das \class{CompletingCallable} sorgt dafür, dass das zurückgegebene \class{CompletableFuture} korrekt abgeschlossen wird und dieses ist wiederum für dafür zuständig, Anweisungen an das interne \class{Future}-Objekt weiterzugeben.

Auf diese Art und Weise lassen sich nun die meisten Aufgaben lösen, die in der Blocklib Nebenläufigkeit nutzen. Welche Anweisungen angepasst werden, wird im folgenden Abschnitt beschrieben.

\subsubsection{Konsolidierung mit dem bestehenden System}\label{sec:Konsolidierung}

