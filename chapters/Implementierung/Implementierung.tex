Ebenso wie der Entwurf, ist auch die Implementierung der nebenläufigen Architektur prinzipiell in zwei Bereiche unterteilt, die Implementierung des Render-Threads und die Implementierung des Jobsystems. Um einen Render-Thread in die Architektur der Blocklib zu integrieren, muss besonders darauf geachtet werden, dass Wettkampfbedingungen vermieden werden. Wie in Abschnitt~\vref{sec:desgignRender-Thread} beschrieben, kann dies unter anderem durch die Nutzung von Double-Buffern gelingen. 

Da ein Jobsystem implementiert wird, können alle Simulationsanweisungen auf Job-Threads ausgeführt werden. Die Threads des Jobsystems führen spezielle Anweisungen aus, um Jobs entgegenzunehmen. Es wäre somit aufwändig, den Thread, der in Java mit dem Start des Programms erzeugt wird -- den \code{main}-Thread -- in das Jobsystem zu integrieren, da der Entwurf des Jobsystems vorsieht, dass der von Java bereitgestellte \classScheduledThreadPoolExecutor{} zur Ausführung nebenläufiger Tasks verwendet wird. Diese Klasse erzeugt die genutzten Worker-Threads allerdings selbst und lässt nicht zu, bestehende Threads ihren Thread-Pool mitaufzunehmen. Ungeachtet dessen ist es selbst unter Verwendung einer selbst implementierten \classExecutor{}-Klasse weiterhin einfacher, den \code{main}-Thread als Render-Thread zu nutzen, als in die Thread-Generierung der \classExecutor{}-Klasse einzugreifen, um den \code{main}-Thread in das Jobsystem zu integrieren und zugleich einen separaten Rendering-Thread neu zu erzeugen. Folglich wird der \code{main}-Thread als Render-Thread genutzt, um das Rendering auszuführen. Alle anderen \glspl{Rechenprozess} werden über das Jobsystem auf durch die \classExecutor{}-Klasse erzeugten Threads durchgeführt. Folgend wird zunächst die Implementierung des Render-Threads beschrieben. Im darauffolgenden Abschnitt wird die Implementierung des Jobsystems erläutert.