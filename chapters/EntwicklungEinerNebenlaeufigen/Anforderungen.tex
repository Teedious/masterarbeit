Aus der in Abschnitt~\ref{sec:blocklibAnalyse} beschriebenen Analyse lassen sich einige Anforderungen ableiten, die von der nebenläufigen Architektur erfüllt werden müssen. Neben den aus der Analyse erwachsenen Anforderungen, lassen sich weitere Anforderungen definieren, die für die Blocklib in Zukunft nützlich sind.

Die Schnittstelle der nebenläufigen Architektur, im Folgenden auch \emph{API} genannt, muss in das bestehende Ökosystem der Codebasis der Blocklib integriert sein, damit sie tatsächlich genutzt wird.

\subsubsection{Kontrolle über Threads an einer Stelle}
Um die Nutzung der API einfach zu gestalten, ist es notwendig, die Verwaltung und Kontrolle über die Java-Threads, die nebenläufige \glspl{Anweisung} ausführen, hinter der API zu verstecken. Der Lebenszyklus eines Threads ist für die asynchrone Abarbeitung von Tasks irrelevant, kann allerdings gegebenenfalls komplex sein, wenn beispielsweise dynamisch Threads erzeugt oder beendet werden oder ermittelt wird, wann ein Thread welche Tasks abarbeitet. Diese Komplexität darf nicht zu den Nutzern der API vordringen.

Zudem ist es sinnvoll, diese Verwaltung an einer Stelle zu bündeln, um den Überblick über die Anzahl der Java-Threads nicht zu verlieren, damit Kontextwechsel möglichst vermieden werden können. Diese Übersicht und Kontrolle lässt sich am besten an einer Stelle gebündelt verwirklichen.

Des Weiteren wird so Redundanz in der Codebasis verringert, da der Code zur Verwaltung der Threads nur an einer Stelle benötigt wird. Gäbe es hier mehrere Orte, würde sich beispielsweise der Code, der für die Generierung eines Java-Threads zuständig ist, an mehreren Stellen wiederholen. Dies ginge dann mit den üblichen Problemen von Redundanz einher. Änderungen sind aufwendiger, da sie an allen Stellen durchgeführt werden müssen und mit der Zeit unterscheiden sich die verschiedenen Codeteile, da vergessen wird Änderungen an allen Orten durchzuführen.

\subsubsection{Verteilung von Berechnungen an Worker-Threads}
Wie in Abschnitt~\ref{sec:nutzungMultithreading} beschrieben, werden Threads für die Generierung von Chunks genutzt. Die Blocklib benötigt also eine Möglichkeit \glspl{Anweisung} asynchron an ein Jobsystem zu übergeben. Das Jobsystem kann in Zukunft auch für die Übergabe anderer asynchroner Aufgaben genutzt werden. So kann die Blocklib die vorhandene Parallelität in der Hardware voll ausnutzen. Das Ziel ist, durch Worker-Threads immer möglichst viele Tasks parallel ausführen zu können, sofern genügend Tasks vorhanden sind.

\subsubsection{Einfaches starten von Hintergrundtasks und einmaligen Aufgaben}\label{sec:reqBackgroundTasks}
Einige Systeme der Blocklib, wie beispielsweise das System zu Berechnung von Flüssigkeitsbewegungen, führen Aufgaben durch, die periodisch im Hintergrund ablaufen. So wird im Flüssigkeitssystem für jede Flüssigkeit nach einem eigenen Zeitintervall geprüft, wohin die Flüssigkeit fließt. Es muss eine einfache Möglichkeit geben solche periodischen Aufgaben an die Threading API zu übergeben, die sich dann um die Ausführung zur korrekten Zeit kümmert.

Auch die Möglichkeit der Definition einer Aufgabe, die nach dem Ablauf eines festgelegten Intervalls einmalig ausgeführt wird, ist wünschenswert. Ein Anwendungsfall wäre beispielsweise eine Art Falle, die durch das Betreten eines bestimmten Blocks in der Blocklib ausgelöst wird und dann nach wenigen Sekunden zuschnappt. Ein solches System ließe sich dann durch die API einfach realisieren.

Die Klasse ChunkStorage erzeugt für jeden zu ladenden Chunk einen Task für die Generierung und einen Task, um das zugehörige Mesh zu erzeugen. In vielen Situationen, wie dem Start der Blocklib, Teleportation der Kamera durch einen Konsolen-Befehl oder schnelle Bewegung der Kamera, wird dadurch eine sehr große Anzahl dieser Tasks erzeugt. Beim Start der Blocklib werden bei einer geladenen Anzahl von $15$ Chunks in  $x$-, $y$- und $z$- Richtung bis zu $2\cdot15^3=6750$  Tasks auf einmal erzeugt. Für Abarbeitung dieser Tasks benötigen die meisten Rechner mehr Zeit, als in einem Frame zur Verfügung steht (möchte man eine Bildwiederholgeschwindigkeit von mindestens 60~\ac{fps} erreichen, stehen pro Frame maximal \SI{16,67}{\milli\second} zur Verfügung). Daher müssen diese Hintergrundtasks anders behandelt werden, sodass deren Ausführung nicht die Durchführung von Tasks behindert, die für die Berechnung eines Frames notwendigerweise durchgeführt werden müssen. Die Besonderheit der Blocklib, dass sich die Anzahl der Tasks  dynamisch von Frame zu Frame stark unterscheiden kann, muss also berücksichtigt werden.