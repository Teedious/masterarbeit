Aus der in Abschnitt~\ref{sec:blocklibAnalyse} beschriebenen Analyse lassen sich einige Anforderungen ableiten, die von der nebenläufigen Architektur erfüllt werden müssen. Neben den aus der Analyse erwachsenen Anforderungen, lassen sich weitere Anforderungen definieren, die für die Blocklib in Zukunft nützlich sind.

Die Schnittstelle der nebenläufigen Architektur, im Folgenden auch \emph{API} genannt, muss sich in das bestehende Ökosystem der Codebasis der Blocklib integrieren, sodass deren Nutzung möglichst einfach von der Hand geht und angenommen wird.

\subsubsection{Kontrolle über Threads an einer Stelle}
Um die Nutzung der API einfach zu gestalten, ist es notwendig, die Verwaltung und Kontrolle über die Java-Threads, die nebenläufige \glspl{Anweisung} ausführen, hinter der API zu verstecken. Der Lebenszyklus eines Threads ist für die asynchrone Abarbeitung von Tasks irrelevant, kann allerdings gegebenenfalls komplex sein, wenn beispielsweise dynamisch Threads erzeugt oder beendet werden oder ermittelt wird, wann ein Thread welche Tasks abarbeitet. Diese Komplexität darf nicht zu den Nutzern der API vordringen.

Zudem ist es sinnvoll, diese Verwaltung an einer Stelle zu bündeln, um den Überblick über die Anzahl der Java-Threads nicht zu verlieren, damit durch die Auswahl einer geeigneten Zahl Kontextwechsel möglichst vermieden werden können. Diese Übersicht und Kontrolle lässt sich am besten an einer Stelle gebündelt verwirklichen.

Des Weiteren wird so Redundanz in der Codebasis verringert, da der Code zur Verwaltung der Threads nur an einer Stelle benötigt wird. Gäbe es hier mehrere Orte, würde sich beispielsweise eventuell der Code, der für die Generierung eines Java-Threads zuständig ist, an mehreren Stellen wiederholen. Dies ginge dann mit den üblichen Problemen von Redundanz einher. Mit der Zeit unterscheiden sich die verschiedenen Codeteile, da vergessen wird Änderungen an allen Orten durchzuführen und Änderungen sind aufwendiger, da sie an allen Stellen durchgeführt werden müssen.

\subsubsection{Verteilung von Berechnungen an Worker-Threads}
Wie in Abschnitt~\ref{sec:nutzungMultithreading} beschrieben, werden für die Generierung von Chunks Threads genutzt. Die Blocklib benötigt also eine Möglichkeit \glspl{Anweisung} asynchron an einen Executor zu übergeben. Der Executor kann in Zukunft auch für Übergabe anderer asynchroner Aufgaben genutzt werden. So kann die Blocklib die vorhandene Parallelität in der Hardware voll ausnutzen. Das Ziel ist, durch Worker-Threads immer möglichst viele Tasks parallel ausführen zu können, wenn genügend Tasks vorhanden sind.

\subsubsection{Einfaches starten von Hintergrundtasks und einmaligen Aufgaben}\label{sec:reqBackgroundTasks}
Einige Systeme der Blocklib, wie beispielsweise das System zu Berechnung von Flüssigkeitsbewegungen, führen Aufgaben durch, die periodisch im Hintergrund ablaufen. So wird Im Flüssigkeitssystem für jede Flüssigkeit nach einem eigenen Zeitintervall geprüft, wohin die Flüssigkeit fließt. Es muss eine einfache Möglichkeit geben solche periodischen Aufgaben an die Threading API zu übergeben, die sich dann um die Ausführung zur korrekten Zeit kümmert.

Damit verwandt ist, eine Aufgabe zu definieren, die nach dem Ablauf eines festgelegten Intervalls einmalig ausgeführt wird. Man überlege sich beispielsweise eine Art Falle, die durch das Betreten eines bestimmten Blocks in der Blocklib ausgelöst wird und dann nach ein paar Sekunden zuschnappt. Ein solches System gibt es in der Blocklib zwar noch nicht, ließe sich dann durch die API allerdings einfach realisieren.

Die Klasse ChunkStorage erzeugt für jeden zu ladenden Chunk einen Task für die Generierung und einen Task, um das zugehörige Mesh zu erzeugen. In vielen Situationen, wie dem Start der Blocklib, Teleportation der Kamera durch einen Konsolen-Befehl oder schnelle Bewegung der Kamera, wird dadurch eine sehr große Anzahl dieser Tasks erzeugt. Beim Start der Blocklib werden bei einer geladenen Anzahl von $15$ Chunks in  $x$-, $y$- und $z$- Richtung bis zu $2\cdot15^3=6750$  Tasks auf einmal erzeugt. Für Abarbeitung dieser Tasks benötigen die meisten Rechner mehr Zeit, als in einem Frame zur Verfügung steht (möchte man eine Bildwiederholgeschwindigkeit von mindestens 60~\ac{fps} erreichen, stehen pro Frame maximal \SI{16,67}{\milli\second} zur Verfügung). Daher müssen diese Hintergrundtasks anders behandelt werden, sodass deren Ausführung nicht die Durchführung von Tasks behindert, die für die Berechnung eines Frames notwendigerweise durchgeführt werden müssen. Die Besonderheit der Blocklib, dass sich die Anzahl der Tasks  dynamisch von Frame zu Frame stark unterscheiden kann, muss also berücksichtigt werden.