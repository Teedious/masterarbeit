In Java können Threads über ein einheitliches Interface verwaltet werden. Zur Entkopplung von dem Betriebssystem übernimmt das \emph{Java-Runtime-Environment} die Aufrufe der betriebssystemspezifischen Funktionen zur Erzeugung und Verwaltung eines Threads~\cite[S.~3]{Friesen2015}. Das einheitliche Interface wird durch die Klasse \class{Thread} repräsentiert, die einen Java-Thread von einem Thread des  Betriebssystems entkoppelt. 

Um die Ausführung eines Java-Threads zu starten, wird dessen Methode \code{start()} aufgerufen~\cite[S.~8]{Friesen2015}. Ohne eine Angabe der auszuführenden \glspl{Anweisung} ist allerdings noch nicht definiert, welche \glspl{Aktivitaet} der Thread bei der Ausführung durchführen soll. Java enthält das Interface \class{Runnable}, das eine einzige Methode \code{run()} definiert, die weder Parameter noch Rückgabewert besitzt. Die Klasse \class{Thread} besitzt Konstruktoren, die als Argument ein Objekt erwarten, das \class{Runnable} implementiert. Wird dann der Java-Thread mittels \code{start()} gestartet, so wird in der Ausführung die \code{run()}-Methode des übergebenen Objekts aufgerufen~\cite[S.~3]{Friesen2015}. Ein einfaches \gls{Programm}, das auf diese Weise arbeitet, könnte wie Listing~\ref{lst:simpleThreadExample} aussehen.
\begin{lstlisting}[caption={[Beispiel für ein Java-\glsentrylong{Programm}, das einen mit einem \class{Runnable}-Objekt einen Thread erzeugt und dann startet.]Beispiel für ein Java-\gls{Programm} das einen mit einem \class{Runnable}-Objekt einen Thread erzeugt und dann startet.},label={lst:simpleThreadExample},float={htbp}]
public static void main(String[] args) {
	var helloThread = new Thread(new Runnable() {
		@Override
		public void run() {
			System.out.println("Hello thread!");
		}
	});
	helloThread.start();
}
\end{lstlisting}
Das \gls{Programm} erzeugt ein Java-Thread-Objekt, dem eine Implementierung von \class{Runnable} übergeben wird. In diesem Beispiel wird nur der Text \enquote{Hello thread!} ausgegeben. Hier könnte sich natürlich ein beliebiger Algorithmus befinden, der dann in dem Thread ausgeführt wird.

Alternativ kann eine Klasse von \class{Thread} abgeleitet werden, da \class{Thread} selbst \class{Runnable} implementiert, und dann die Definition von \code{run()} überschrieben werden~\cite[S.~335]{Rauber2006}. Da die Klasse von \class{Thread} erbt, besitzen Objekte der Klasse ebenfalls die Methode \code{start()}. Wird diese aufgerufen, so wird wie bei \class{Thread} ein Betriebssystem-Thread gestartet, der nun die überschriebene Definition von \code{run()} ausführt. Das Erben von \class{Thread} ist im Normalfall nicht empfohlen, da ein solcher Entwurf einige Schwierigkeiten verursachen kann. Beispielsweise kann die Thread-Unterklasse von keiner anderen Klasse mehr erben~\cite[S.~335]{Rauber2006}, zudem sind die Definition der \glspl{Anweisung} mit der Definition der Ausführung stark gekoppelt.

\subsubsection{Synchronisierung in Java}
Die Bandbreite der Möglichkeiten zur Synchronisierung in Java ist sehr groß. Daher werden hier nur einige ausgewählte Methoden dargestellt. Für eine ausführlichere Lektüre zu dem Thema können die Bücher von \textcite{Friesen2015} und \textcite{Hettel2016} empfohlen werden.

\paragraph{\texttt{synchronized}} Das Schlüsselwort \code{synchronized} ermöglicht die blockierende Synchronisierung beim Zugriff auf beliebige Objekte. Das Schlüsselwort kann auf zwei Arten eingesetzt werden~\Cite[S.~339~ff.]{Rauber2006}. Einerseits kann ein Code-Block definiert werden, in dem der Zugriff auf ein Objekt synchronisiert wird, wie in Listing~\ref{lst:synchronizedExample}.
\begin{lstlisting}[caption={[Beispiel eines Java-\glsentryuseri{Programm} mit Nutzung von \code{synchronized}.]Beispiel eines Java-\glsuseri{Programm}, das \code{synchronized} zur Synchronisierung nebenläufiger \glspl{Anweisung} nutzt.}, label={lst:synchronizedExample},float={htbp}]
public class MultithreadedIncrement {
	public static Integer count = 0;
	public static void main(String[] args) {
		var increment = new Runnable(){
			@Override
			public void run() {
				synchronized (count){
					count++;
					System.out.println(count);
				}
			}
		};
		new Thread(increment).start();
		new Thread(increment).start();
	}
}	
\end{lstlisting}
Das \gls{Programm} definiert ein statisches Feld \code{count}, dann wird ein \class{Runnable} implementiert, das einen \code{synchronized}-Block enthält. Soll ein Thread diesen Block ausführen, versucht er automatisch die zu \code{count} gehörige Sperre erhalten. Dieser Vorgang ist threadsicher und nur ein Thread kann die Sperre zu einem Objekt gleichzeitig besitzen. Dadurch ist es nun möglich, gefahrlos den Wert von \code{count} zu erhöhen und den neuen Wert auf der Konsole auszugeben. Beim Verlassen des \code{synchronized}-Blocks wird die Sperre des zugehörigen Objekts wieder freigegeben. Ist die Sperre belegt, wenn ein Thread diese erhalten möchte, wird die Ausführung des Threads solange suspendiert, bis die Sperre freigegeben wird. Java ordnet jedem Objekt implizit eine solche Sperre zu~\cite{Friesen2015}, sodass \code{synchronized} mit beliebigen Objekten genutzt werden kann. Für primitive Datentypen ist das nicht möglich (weswegen \code{count} in Listing~\ref{lst:synchronizedExample} als Objekt-Typ \class{Integer} und nicht als \code{int} definiert ist).

Das Schlüsselwort \code{synchronized} kann auch als Teil der Definition einer Methode verwendet werden. In diesem Fall wird kein Objekt angegeben, dessen Zugriff synchronisiert werden soll, sondern das Objekt ist automatisch implizit definiert. Bei Instanz-Methoden ist das automatisch das Objekt selbst, das die Methode ausführt, also \code{this}. Bei statischen Methoden wird der Zugriff auf das Klassen-Objekt synchronisiert.

\paragraph{\texttt{volatile}} Variablen können mit dem Schlüsselwort \code{volatile} ausgestattet werden. Threads, die auf eine als \code{volatile} gekennzeichnete Variable zugreifen, lesen immer den aktuellen Wert dieser Variablen und greifen dafür immer auf den Hauptspeicher zu anstatt auf den Cache (der schon veraltet sein könnte)~\cite[S.~30~ff.]{Friesen2015}. Java stellt sicher, dass Lese- und Schreibvorgänge einer \code{volatile} Variablen immer atomar und damit threadsicher sind.

Das gilt insbesondere auch für 64-bit Variablen. Obwohl einige Quellen davor warnen, \code{volatile} für Variablen des Typs \code{long} oder \code{double} zu verwenden (unter dem Verweis darauf, dass 32-bit Computer zwei Operationen für das Lesen und Schreiben dieser Variablen benötigen~\cite[S.~34]{Friesen2015}), beschreibt die Java Spezifikation explizit, dass auch der Zugriff auf 64-bit Variablen immer atomar ist, sofern diese als \code{volatile} deklariert sind~\cite{Java7Spec17}. Weiter wird dort insbesondere darauf hingewiesen, dass Entwickler aus diesem Grund 64-bit Variablen, auf die von mehreren Threads zugegriffen wird, als \code{volatile} deklarieren sollen, um Atomarität von Lese- und Schreibzugriffen zu gewährleisten. Lesen und subsequentes Schreiben einer \code{volatile} Variablen (beispielsweise \code{count++}) ist allerdings weiterhin nicht atomar, da mehr als nur eine Operation durchgeführt wird -- Lesen, neuen Wert berechnen und Schreiben. \code{volatile} ist also nur dann zu verwenden, wenn der neue Wert einer Variablen nicht von dem alten Wert abhängt, beispielsweise, wenn er gänzlich neu berechnet wird. 

\paragraph{Atomics und Concurrent Collections} Da die Änderung von Variablen basierend auf ihrem vorherigen Wert häufig nötig ist (beispielsweise für die Generierung einer fortlaufenden Nummer) und die ständige Synchronisierung der Variablen über \code{synchronized} oder andere blockierende Methoden beträchtliche Performance-Einbußen zur Folge haben können~\cite[S.~130]{Friesen2015}, enthält Java sogenannte \emph{Atomics}. Atomics verpacken bestimmte Datentypen und ermöglichen, atomare Operationen auch auf Basis des aktuellen Werts einer Variablen durchzuführen ohne dabei den Zugriff auf diese Variable durch eine Sperre zu blockieren~\cite[S.~130]{Friesen2015}. 

Java stellt dafür unter anderem die Klassen \class{AtomicBoolean}, \class{AtomicInteger}, \class{AtomicLong} und \class{AtomicReference}
bereit~\cite[S.~131]{Friesen2015}. Klassen für die Datentypen \code{byte}, \code{short}, \code{float} und \code{double} gibt es nicht. Die Java Dokumentation erklärt dies damit, dass diese über \class{AtomicInteger} und im Fall von \code{double} über \class{AtomicLong} dargestellt werden können~\cite{Java7DocAtomic}.

Eine nützliche Anwendung von Atomics ist die threadsichere Beschränkung einer Klasse auf eine Objekt-Instanz, ohne globalen Zugriff auf diese bereitstellen zu müssen, wie es bei der Standardimplementierung eines \gls{singleton} der Fall wäre (das \gls{singleton} ist ein Entwurfsmuster, das die zwei Aufgaben, nur eine Objekt-Instanz und globaler Zugriff, gemeinsam löst). Allerdings ermöglicht diese Implementierung keine Prüfung während des Kompiliervorgangs, sondern erst zur Laufzeit.
\begin{lstlisting}[caption={Implementierung einer Klasse, die nur einmal instanziiert werden kann.}, label={lst:LocalSingleton},float={htbp}]
public class LocalSingleton {
private static AtomicBoolean instanced = new AtomicBoolean(false);

public LocalSingleton() {
	ensureUniqueInstance();
}

private void ensureUniqueInstance(){
	if(!instanced.compareAndSet(false, true)){
		throw new UnsupportedOperationException();
	}
}
\end{lstlisting}
Die in Listing~\ref{lst:LocalSingleton} gezeigte Klasse \class{LocalSingleton} nutzt eine statische Instanz von \class{AtomicBoolean}, um im Konstruktor zu überprüfen, ob bereits eine Instanz von \class{LocalSingleton} erzeugt wurde. Ist das der Fall, wird eine Exception geworfen und das Objekt kann nicht erzeugt werden. Dazu wird eine Compare-and-Set-Instruktion verwendet.

Compare-and-Swap- und  Compare-and-Set-Instruktionen werden ebenfalls in den von Java bereitgestellten \emph{Concurrent Collections} verwendet~\cite[S. 133~f.]{Friesen2015}. Es gibt unter anderem verschiedene nicht-blockierende Implementierungen für Warteschlangen (\class{ConcurrentLinkedQueue}), Zuordnungstabellen (\class{ConcurrentHashMap}), Mengen (\class{ConcurrentSkipListSet}). Diese sind selbstverständlich besonders nützlich, wenn verschiedene Threads auf solche Datenstrukturen zugreifen müssen, da keine explizite Synchronisierung nötig ist und keine Sperren verwendet werden, welche sich zu einem Flaschenhals entwickeln können~\cite[S.~125~ff.]{Friesen2015}.

\subsubsection{Executors}\label{sec:executor} Neben Möglichkeiten zur Synchronisierung bietet das Concurrency Framework in Java zudem Klassen und Interfaces, die die Verwaltung und Ausführung nebenläufiger Aufgaben vereinfachen, sodass keine Verwaltung von \class{Thread}-Objekten nötig ist. Die Interfaces \class{Executor} und \class{ExecutorService} liefern eine einheitliche Schnittstelle, um die Übergabe von nebenläufigen \glspl{Anweisung} von der Verwaltung der tatsächlichen Ausführung der \glspl{Anweisung} zu trennen~\cite[S.~70~ff.]{Friesen2015}. Das Interface \class{Executor} definiert genau eine Methode \code{execute(...)} ohne Rückgabewert. Die Klasse, die einen Executor nutzt, hat keine Kenntnis über die Anzahl und Beschaffenheit der Threads, die die \glspl{Anweisung} tatsächlich ausführen. Tatsächlich ist nicht einmal bekannt, ob die \glspl{Anweisung} überhaupt in Threads ausgeführt werden. Nutzt ein Executor im Hintergrund Threads für die Ausführung der \glspl{Anweisung}, so werden diese auch \emph{Worker-Threads} und die Menge der Threads \emph{Thread-Pool} genannt.

Das Interface \class{Runnable} definiert eine Schnittstelle für die Definition nebenläufiger \glspl{Anweisung}. Das Konzept der asynchronen Ausführung von \glspl{Anweisung}, die ein Ergebnis liefern, wird davon jedoch nicht abgedeckt. Diese Lücke schließt das Interface \class{Callable<V>}, das die Methode \code{call()} enthält, die ein Objekt des generischen Typs \code{V} zurückgibt, und somit beliebige Rückgabewerte ermöglicht. \textcite{Friesen2015} nennt ein Objekt, das entweder das Interface \class{Runnable} oder das Interface \class{Callable} implementiert, \emph{Task}. Diese Konvention wird hier übernommen. 

Analog zur Erweiterung der Möglichkeiten durch \class{Callable} erweitert das Interface \class{ExecutorService} die Möglichkeiten der Ausführung von Tasks. Während das Interface \class{Executor} lediglich die Ausführung von Runnables ermöglicht, kann ein Objekt, das \class{ExecutorService} implementiert, auch die Ausführung von Callables verwalten. Zudem definiert das Interface Methoden, die den Lebenszyklus der implementierenden Objekte selbst betreffen, wie beispielsweise \code{shutdown()}. Bei der Übergabe eines \code{Callable}-Objekts an einen \class{ExecutorService} gibt dieser ein \class{Future<V>}-Objekt zurück, das die Interaktion mit der asynchronen \gls{Anweisung} ermöglicht. Ein vollständiges Klassendiagramm der beschriebenen Interfaces ist in Anhang~\ref{appendix:concFrameworkExecutor} enthalten.

\subsubsection{Koordinierung asynchroner Tasks}\label{sec:CompletableFuture}
Die Methoden von \class{Future<V>} ermöglichen zwar gewisse Interaktionen, wie mittels \code{get()} auf die Fertigstellung der asynchronen \gls{Anweisung} zu warten und deren Rückgabewert zu erhalten. Möglichkeiten zur Komposition voneinander abhängiger Tasks bietet das Interface allerdings nicht. \textcite[S.~240]{Hettel2016} nennen das ein \emph{pull-basiertes} Interface. Ein Entwickler muss also explizit abfragen, ob ein asynchroner Task bereits abgeschlossen ist. Dies erzeugt die Gefahr Threads zu blockieren, da sie auf die Werte und damit auf die Fertigstellung anderer Tasks warten müssen~\cite[S.~239]{Hettel2016}.

Die Klasse \class{CompletableFuture<V>} implementiert dagegen zusätzlich das \emph{push-basierte} Interface \class{CompletionStage} und übernimmt die Verwaltung der Komposition asynchroner Tasks~\cite[S.~240~ff.]{Hettel2016}. Damit wird die Verkettung, Aufspaltung, Zusammenführung und Auswahl von Tasks ermöglicht~\cite[S.~250~ff.]{Hettel2016}. Mit Verkettung ist die Ausführung eines Tasks nach einem anderen gemeint. Aufspaltung bezeichnet die Ausführung mehrerer Tasks nach der Vollendung eines Tasks. Zusammenführung ist die Ausführung eines Tasks, nachdem mehrere andere Tasks abgeschlossen sind. Mit Auswahl ist die Möglichkeit gemeint, einen Task zu starten, nachdem der schnellere von zwei vorherigen Tasks abgeschlossen ist. Ein Klassendiagramm von \class{CompletionStage} ist in Anhang~\ref{appendix:CompletionStage} zu finden. Dort werden den genannten Kompositionsmöglichkeiten die jeweiligen Methoden zugeordnet.