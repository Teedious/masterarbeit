In Java können Threads über ein einheitliches Interface verwaltet werden. Zur Entkopplung vom Betriebssystem übernimmt die Java Runtime die Aufrufe der betriebssystemspezifischen Funktionen zur Erzeugung und Verwaltung eines Threads~\cite[S.~3]{Friesen2015}. Das einheitliche Interface wird durch die Klasse \class{Thread} repräsentiert, die einen Java Thread von einem Thread des  Betriebssystems entkoppelt. 

Um die Ausführung eines Java Threads zu starten, wird dessen Methode \code{start(): void} aufgerufen~\cite[S.~8]{Friesen2015}. Ohne eine Angabe der auszuführenden Anweisungen ist allerdings noch nicht definiert, welche Aktivitäten der Thread bei der Ausführung durchführen soll. Java enthält das Interface \class{Runnable}, das eine einzige Methode \code{run(): void} definiert, die weder Parameter noch Rückgabewert besitzt. Die Klasse \class{Thread} besitzt Konstruktoren die als Argument ein Objekt erwarten, das \class{Runnable} implementiert, wird der Java Thread gestartet, so wird in der Ausführung die \code{run()} Methode des übergebenen Objekts aufgerufen~\cite[S.~3]{Friesen2015}. Ein einfaches Programm, das auf diese Weise arbeitet, könnte wie folgt aussehen.
\begin{lstlisting}
public static void main(String[] args) {
	var helloThread = new Thread(new Runnable() {
		@Override
		public void run() {
			System.out.println("Hello thread!");
		}
	});
	helloThread.start();
}
\end{lstlisting}
Das Programm erzeugt ein Java Thread Objekt, dem eine Implementierung von \class{Runnable} übergeben wird. In diesem Beispiel wird nur der Text \enquote{Hello thread!} ausgegeben. Hier könnte sich natürliche ein beliebiger Algorithmus befinden, der dann in dem Thread ausgeführt wird.

Alternativ kann eine Klasse von \class{Thread} erben, da \class{Thread} selbst \class{Runnable} implementiert, und die Definition von \code{run()} überschreiben~\cite[S.~335]{Rauber2006}. Da die Klasse von \class{Thread} erbt, besitzen Objekte der Klasse ebenfalls die Methode \code{start()}. Wird diese aufgerufen, so wird wie bei \class{Thread} ein Betriebssystem Thread gestartet, der nun die überschriebene Definition von \code{run()} ausführt. Das Erben von von \class{Thread} ist im Normalfall nicht empfohlen, da dieses Design einige Probleme verursacht. Beispielsweise kann die Thread-Unterklasse von keiner anderen Klasse mehr erben~\cite[S.~335]{Rauber2006}, zudem sind die Definition der Anweisungen mit der Definition der Ausführung höchstmöglich gekoppelt, was dem grundlegenden Prinzip der \emph{losen Kopplung} entgegensteht. Entscheidet man sich also für dieses Design, sollte dies eine gute Begründung haben.

Um die Ausführung mehrerer Java Threads zu koordinieren, bietet Java einige Synchronisationsmechanismen. Diese werden nun vorgestellt

\subsection{Synchronisierung in Java}
Da die Bandbreite der Möglichkeiten zur Synchronisierung in Java ist sehr groß. Daher werden hier nur einige ausgewählte Methoden dargestellt. Für eine ausführlichere Lektüre zu dem Thema lassen sich die Bücher von \textcite{Friesen2015} und \textcite{Hettel2016} empfehlen.

\paragraph{\texttt{synchronized}} Das Schlüsselwort \code{synchronized} ermöglicht die blockierende Synchronisierung beim Zugriff auf beliebige Objekte. Das Schlüsselwort kann auf zwei Arten eingesetzt werden~\Cite[S.~339~ff.]{Rauber2006}. Einerseits kann ein Code-Block definiert werden in dem der Zugriff auf ein Objekt synchronisiert wird, wie in folgendem Beispiel.
\begin{lstlisting}
public class MultithreadedIncrement {
	public static Integer count = 0;
	public static void main(String[] args) {
		var increment = new Runnable(){
			@Override
			public void run() {
				synchronized (count){
					count++;
					System.out.println(count);
				}
			}
		};
		new Thread(increment).start();
		new Thread(increment).start();
	}
}	
\end{lstlisting}
Das Programm definiert ein statisches Feld \code{count}, dann wird ein \class{Runnable} implementiert, das einen \code{synchronized} Block enthält. Versucht ein Thread, diesen Block auszuführen, versucht er automatisch die zu \code{count} gehörige Sperre erhalten. Dieser Vorgang ist threadsicher und nur ein Thread kann die Sperre zu einem Objekt gleichzeitig besitzen. Dadurch ist es nun möglich, gefahrlos den Wert von \code{count} zu erhöhen und den neuen Wert auf der Konsole auszugeben. Beim Verlassen des \code{synchronized} Blocks wird die Sperre des zugehörigen Objekts wieder freigegeben. Ist die Sperre nicht belegt, wenn ein Thread diese erhalten möchte, wird die Ausführung des Threads solange suspendiert, bis diese freigegeben wird. Java ordnet jedem Objekt implizit eine solche Sperre zu~\cite{Friesen2015}, sodass \code{synchronized} mit beliebigen Objekten genutzt werden kann. Für primitive Datentypen ist das nicht möglich.

Das Schlüsselwort \code{synchronized} kann auch als Teil der Signatur einer Methode verwendet werden, in diesem Fall wird kein Objekt angegeben, dessen Zugriff synchronisiert werden soll. Bei Instanzmethoden ist das automatisch das Objekt selbst, das die Methode ausführt also \code{this}, bei statischen Methoden wird der Zugriff auf das Klassenobjekt synchronisiert.

\paragraph{\texttt{volatile}} Variablen können mit dem Schlüsselwort \code{volatile} ausgestattet werden. Threads, die auf eine als \code{volatile} gekennzeichnete Variable zugreifen, lesen immer den aktuellsten Wert dieser Variable und greifen dafür immer auf den Hauptspeicher zu anstatt auf den Cache (der schon veraltet sein könnte)~\cite[S.~30~ff.]{Friesen2015}. Lese- und Schreibvorgänge einer \code{volatile} Variable sind atomar, und damit threadsicher.

Dies gilt insbesondere auch für 64-bit Variablen. Obwohl einige Quellen davor warnen beispielsweise \code{volatile} für Variablen des Typs \code{long} oder \code{double} zu verwenden, unter dem Verweis darauf, dass 32-bit Computer zwei Operationen für das Lesen und Schreiben dieser Variablen benötigen~\cite[S.~34]{Friesen2015}, beschreibt die Java Spezifikation explizit, dass auch der Zugriff auf 64-bit Variablen immer atomar ist, sofern diese als \code{volatile} deklariert sind~\cite{Java7Spec17}. Weiter wird dort insbesondere darauf hingewiesen, dass Entwickler aus diesem Grund 64-bit Variablen, auf die von mehreren Threads zugegriffen wird, als \code{volatile} zu deklarieren, um Atomarität von Lese- und Schreibzugriffen zu gewährleisten. Lesen und subsequentes schreiben einer \code{volatile} Variable (beispielsweise \code{count++;}) ist allerdings weiterhin nicht atomar, da mehr als nur eine Operation durch geführt wird -- Lesen, neuen Wert berechnen und Schreiben. \code{volatile} ist also nur dann zu verwenden, wenn der neue Wert einer Variable nicht vom alten Wert abhängt, beispielsweise, wenn er gänzlich neu berechnet wird. 

\paragraph{Atomics und Concurrent Collections} Da das Ändern von Variablen basierend auf ihrem vorherigen Wert offensichtlicherweise häufig nötig ist (beispielsweise für die Generierung einer fortlaufenden Nummer) und die ständige Synchronisierung der Variable über \code{synchronized} oder andere blockierende Methoden beträchtliche Performanceeinbußen zur Folge haben können~\cite[S.~130]{Friesen2015}, enthält Java \emph{Atomics}. Atomics sind Wrapper für bestimmte Datentypen, die es erlauben, atomare Operationen auch auf Basis des aktuellen Werts einer Variable durchzuführen ohne dabei den Zugriff auf diese Variable durch eine Sperre zu blockieren~\cite[S.~130]{Friesen2015}. 

Java stellt unter anderem die Klassen \class{AtomicBoolean}, \class{AtomicInteger}, \class{AtomicLong} und \class{AtomicReference}
\todo{Fix lstinline}
% https://tex.stackexchange.com/questions/69346/how-to-deal-with-very-long-lstinline-phrases-like-long-class-names?noredirect=1&lq=1
% https://ftp.tu-chemnitz.de/pub/tex/macros/latex/contrib/listings/listings.pdf
% https://de.wikibooks.org/wiki/LaTeX-W%C3%B6rterbuch:_Silbentrennung
bereit~\cite[S.~131]{Friesen2015}. Klassen für die Datentypen \code{byte}, \code{short}, \code{float} und \code{double} gibt es nicht. Die Java Dokumentation erklärt dies damit, dass diese über \class{AtomicInteger} und im Fall von \code{double} über \class{AtomicLong} dargestellt werden können~\cite{Java7DocAtomic}.

Eine nützliche Anwendung von Atomics ist die threadsichere Beschränkung einer Klasse auf eine Objektinstanz, ohne globalen Zugriff auf diese bereitstellen zu müssen wie es bei der Standardimplementierung eines Singleton der Fall wäre. Allerdings ermöglicht diese Implementierung keine Prüfung während des Kompiliervorgangs sondern erst zur Laufzeit.
\begin{lstlisting}
public class LocalSingleton {
private static AtomicBoolean instanced = new AtomicBoolean(false);

public LocalSingleton() {
	ensureUniqueInstance();
}

private void ensureUniqueInstance(){
	if(!instanced.compareAndSet(false, true)){
		throw new UnsupportedOperationException();
	}
}
\end{lstlisting}
Die gezeigte Klasse \class{LocalSingleton} nutzt eine statische Instanz von \class{AtomicBoolean}, um im Konstruktor zu überprüfen, ob bereits eine Instanz von \class{LocalSingleton} erzeugt wurde. Ist dies der Fall, wie eine Exception geworfen und das Objekt kann nicht erzeugt werden. Dazu wird eine Compare-and-Swap Instruktion verwendet, die in Java \code{compareAndSet(...)} genannt wird.

Compare-and-Swap Instruktionen werden ebenfalls in den von Java bereitgestellten \emph{Concurrent Collections} verwendet~\cite[S. 133~f.]{Friesen2015}. Es gibt verschiedene nicht-blockierende Implementierungen für Warteschlangen (\class{ConcurrentLinkedQueue}), Maps (\class{ConcurrentHashMap}), Mengen (\class{ConcurrentSkipListSet}) und viele weitere. Diese sind selbstverständlich besonders nützlich, wenn verschiedene Threads auf solche Datenstrukturen zugreifen müssen, da keine explizite Synchronisierung nötig ist und keine Sperren verwendet werden, welche sich zu einem Flaschenhals entwickeln könnten~\cite[S.~125~ff.]{Friesen2015}.

\subsection{Executors}\label{sec:executor} Neben Möglichkeiten zur Synchronisierung bietet das Concurrency Framework in Java zudem Klassen und Interfaces, die die Verwaltung und Ausführung nebenläufiger Aufgaben vereinfachen. Die Interfaces \class{Executor} und \class{ExeecutorService} liefern eine einheitliche Schnittstelle, um die Übergabe von nebenläufigen Anweisungen von der Verwaltung der tatsächlichen Ausführung der Anweisungen zu trennen~\cite[S.~70~ff.]{Friesen2015}. Das Interface \class{Executor} definiert genau eine Methode \code{execute(command: Runnable): void}. Die Klasse, die einen Executor nutzt, hat keine Kenntnis über die Anzahl und Beschaffenheit der Threads, die die Anweisungen tatsächlich ausführen. Tatsächlich ist nicht einmal bekannt, ob die Anweisungen überhaupt nebenläufig ausgeführt werden.

Das Interface \class{Runnable} definiert eine Schnittstelle für die Definition nebenläufiger Anweisungen, das Konzept der asynchronen Ausführung von Anweisungen, die ein Ergebnis liefern, wird davon jedoch nicht abgedeckt. Diese Lücke schließt das Interface \class{Callable<V>}, das die generische Methode \code{call(): V} enthält und somit beliebige Rückgabewerte ermöglicht. \textcite{Friesen2015} nennt ein Objekt, das entweder das Interface \class{Runnable} oder das Interface \class{Callable} implementiert, \emph{Task}. Diese Konvention wird hier übernommen. 

Analog zur Erweiterung der Möglichkeiten durch \class{Callable} erweitert das Interface \class{ExecutorService} die Möglichkeiten der Ausführung von Tasks. Während das Interface \class{Executor} lediglich die Ausführung von Runnables ermöglicht, kann ein Objekt, das \class{ExecutorService} implementiert, auch die Ausführung von Callables verwalten. Zudem definiert das Interface Methoden, die den Lebenszyklus der implementierenden Objekte selbst betreffen, wie beispielsweise \code{shutdown(): void}. Bei der Übergabe eines Callables an einen \class{ExecutorService} gibt dieser ein Objekt \class{Future<V>} zurück, das die Interaktion mit der asynchronen Anweisung ermöglicht. Ein vollständiges Klassendiagramm der beschriebenen Interfaces ist in Anhang~\ref{appendix:concFrameworkExecutor} enthalten.

\subsection{Koordinierung asynchroner Tasks}

Die Methoden von \class{Future<V>} ermöglichen zwar gewisse Interaktionen, wie mittels \code{get(): V} auf die Fertigstellung der asynchronen Anweisung zu warten und deren Rückgabewert zu erhalten, Möglichkeiten zur Komposition voneinander abhängiger Tasks bietet das Interface allerdings nicht. Es ist, wie \textcite[S.~240]{Hettel2016} es nennt, ein \emph{pullbasiertes} Interface. Ein Entwickler muss also explizit abfragen, ob ein asynchroner Task bereits abgeschlossen ist. Dies erzeugt die Gefahr Threads zu blockieren, da sie auf die Werte und damit auf die Fertigstellung anderer Tasks warten müssen~\cite[S.~239]{Hettel2016}.

Die Klasse \class{CompletableFuture<V>} bietet dagegen zusätzlich ein \emph{pushbasiertes} Interface, das Interface \class{CompletionStage}. Sie übernimmt also die Verwaltung der Komposition asynchroner Tasks~\cite[S.~240~ff.]{Hettel2016}. Damit wird die Verkettung, Aufspaltung, Zusammenführung und Auswahl von Tasks ermöglicht~\cite[S.~250~ff.]{Hettel2016}. Mit Verkettung ist die Ausführung eines Tasks nach einem anderen gemeint. Aufspaltung bezeichnet die Ausführung mehrerer Tasks nach der Vollendung eines Tasks. Zusammenführung ist die Ausführung eines Tasks, nachdem mehrere andere Tasks abgeschlossen sind. Mit Auswahl ist die Möglichkeit gemeint, einen Task zu starten, nachdem der schnellere von zwei vorherigen Tasks abgeschlossen ist.
\todo{Anhang für CompletableFuture}