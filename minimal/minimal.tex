\documentclass[12pt,a4paper,listof=totocnumbered,parskip=half, abstract=yes]{scrartcl}
\input{../preamble.tex}
\input{../plots}
\input{../glossary}
\pgfplotsset{
	grid=major,
	width=.88\textwidth,
	height=2cm,
	compat=1.18,
  table/search path={../performance/measurements},
}
\graphicspath{ {../img/} }
\tikzexternaldisable

\begin{document}
Betrachtet man nun das vorherige Beispiel der Spielerfigur (also der Klasse \class{Player}), läuft dieser Vorgang wie folgt ab. Die Klasse \class{Player} implementiert indirekt das Interface \class{Renderable}, da sie von der Klasse \class{Entity} abgeleitet ist. Nun wird während der Simulation durch den \class{EntityManager} die \code{draw()}-Methode von \class{Player} aufgerufen. Das \class{Player}-Objekt wird an den \class{MasterRenderer} übergeben. Dieser entnimmt einen \class{RenderedRenderable}-Behälter aus der Liste, der gerade nicht verwendeten Behälter (\emph{Cache}) und befüllt diesen mit den Daten aus dem \class{Player}-Objekt. Jetzt können Änderungen im \class{Player} vorgenommen werden, ohne dass diese die Daten beeinflussen, die zum Zeichnen verwendet werden. Es wird also genau der Zustand dargestellt, den der \class{Player} hat, während die \code{draw()}-Methode aufgerufen wird. der mit den Daten aus \class{Player} befüllte \class{RenderedRenderable}-Behälter wird nun an den \class{OpaqueMasterRenderer} weitergegeben und in der Liste \var{usedRenderables} abgelegt.

\begin{quotation}
	Betrachtet man nun das vorherige Beispiel der Spielerfigur (also der Klasse \class{Player}), läuft dieser Vorgang wie folgt ab. Die Klasse \class{Player} implementiert indirekt das Interface \class{Renderable}, da sie von der Klasse \class{Entity} abgeleitet ist. Nun wird während der Simulation durch den \class{EntityManager} die \code{draw()}-Methode von \class{Player} aufgerufen. Das \class{Player}-Objekt wird an den \class{MasterRenderer} übergeben. Dieser entnimmt einen \class{RenderedRenderable}-Behälter aus der Liste
	
	, der gerade nicht verwendeten Behälter (\emph{Cache}) und befüllt diesen mit den Daten aus dem \class{Player}-Objekt. Jetzt können Änderungen im \class{Player} vorgenommen werden, ohne dass diese die Daten beeinflussen, die zum Zeichnen verwendet werden. Es wird also genau der Zustand dargestellt, den der \class{Player} hat, während die \code{draw()}-Methode aufgerufen wird. der mit den Daten aus \class{Player} befüllte \class{RenderedRenderable}-Behälter wird nun an den \class{OpaqueMasterRenderer} weitergegeben und in der Liste \var{usedRenderables} abgelegt.
\end{quotation}

Betrachtet man nun das vorherige Beispiel der Spielerfigur (also der Klasse \class{Player}), läuft dieser Vorgang wie folgt ab. Die Klasse \class{Player} implementiert indirekt das Interface \class{Renderable}, da sie von der Klasse \class{Entity} abgeleitet ist. Nun wird während der Simulation durch den \class{EntityManager} die \code{draw()}-Methode von \class{Player} aufgerufen. Das \class{Player}-Objekt wird an den \class{MasterRenderer} übergeben. Dieser entnimmt einen \class{RenderedRenderable}-Behälter aus der Liste, der gerade nicht verwendeten Behälter (\emph{Cache}) und befüllt diesen mit den Daten aus dem \class{Player}-Objekt. Jetzt können Änderungen im \class{Player} vorgenommen werden, ohne dass diese die Daten beeinflussen, die zum Zeichnen verwendet werden. Es wird also genau der Zustand dargestellt, den der \class{Player} hat, während die \code{draw()}-Methode aufgerufen wird. der mit den Daten aus \class{Player} befüllte \class{RenderedRenderable}-Behälter wird nun an den \class{OpaqueMasterRenderer} weitergegeben und in der Liste \var{usedRenderables} abgelegt.
\end{document}