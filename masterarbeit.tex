% !TeX spellcheck = de_DE
% !LuaLaTeX
\documentclass[12pt,a4paper,listof=toc,parskip=half,numbers=noenddot,abstract=true]{scrartcl}
\input{preamble}
\input{plots}
\input{glossary}
\begin{document}
\input{titelseite} 
\null\thispagestyle{empty}\clearpage
\includepdf{img/Mastererklaerung.pdf}
\pagenumbering{roman}
\setcounter{page}{1}
\markright{\abstractname}
\begin{abstract}
	TODO meine Zusammenfassung
\end{abstract}
\clearpage
\markright{Inhaltsverzeichnis}
\tableofcontents\clearpage
\listoffigures
\markright{Tabellenverzeichnis und Listings}
\listoftables
\lstlistoflistings\clearpage

\RedeclareSectionCommand[afterindent=no,runin=no,beforeskip=4pt,afterskip=0pt]{section}
\RedeclareSectionCommand[afterindent=no,runin=no,beforeskip=4pt,afterskip=-2pt]{subsection}
\RedeclareSectionCommand[afterindent=no,runin=no,beforeskip=4pt,afterskip=-4pt]{subsubsection}
\RedeclareSectionCommand[afterindent=no,beforeskip=4pt]{paragraph}

\pagebreak
\pagenumbering{arabic}
\setcounter{page}{1}
\setstretch{1.15}

\section{Einleitung}
\input{chapters/Einleitung.tex}


\pagebreak
\section{Grundlagen}\label{kap:grundlagen}
\input{chapters/Grundlagen/PetriNetze.tex}
\input{chapters/Grundlagen/GrundlagenZuThreading.tex}
\subsection{Multithreading in Java}
\input{chapters/Grundlagen/MultithreadingInJava.tex}
\subsection{Multithreading in Spielen}
\input{chapters/Grundlagen/MultithreadingInSpielen.tex}

\pagebreak
\section{Entwurf einer nebenläufigen Architektur}\label{kap:entwurf}
\input{chapters/EntwicklungEinerNebenlaeufigen/intro.tex}

\subsection{Analyse der Blocklib}\label{sec:blocklibAnalyse}
\input{chapters/EntwicklungEinerNebenlaeufigen/AnalyseDerBlocklib.tex}

\subsection{Anforderungen der Blocklib an eine nebenläufige Architektur}\label{sec:anforderungen}
\input{chapters/EntwicklungEinerNebenlaeufigen/Anforderungen.tex}

\subsection{Design der nebenläufigen Architektur}
\input{chapters/DesignDerThreadingApi/Design.tex}
\subsubsection{Design des Renderthreads}\label{sec:desgignRenderthread}
\input{chapters/DesignDerThreadingApi/Renderthread.tex}
\subsubsection{Design des Jobsystems}\label{sec:desgignJobsystem}
\input{chapters/DesignDerThreadingApi/JobApi.tex}

\pagebreak
\section{Implementierung der nebenläufigen Architektur}\label{kap:Implementierung}
\input{chapters/Implementierung/Implementierung.tex}
\subsection{Implementierung des Renderthreads}
\input{chapters/Implementierung/ImplementierungRenderthread.tex}
\input{chapters/Implementierung/UmstellungRenderarchitektur.tex}
\subsubsection{Suche nach Race Conditions}\label{sec:searchRace}
\input{chapters/Implementierung/SucheNachRaceConditions.tex}
\subsection{Implementierung des Jobsystems}
\input{chapters/Implementierung/ImplementierungJobsystem.tex}

\clearpage
\section{Performanceanalyse}\label{kap:performance}
\input{chapters/Performance/0-performance.tex}
\subsection{Szenario 1: Hexagon}
\input{chapters/Performance/1-hexagon.tex}
\subsection{Szenario 2: Halb-Würfel}
\input{chapters/Performance/2-cube.tex}
\subsection{Szenario 3: Welt-Statisch}
\input{chapters/Performance/3-static.tex}
\subsection{Szenario 4: Welt-Rotation}
\input{chapters/Performance/4-rotate.tex}
\subsection{Szenario 5: Welt-Gehen}
\input{chapters/Performance/5-walk.tex}
\subsection{Zusammenfassung}
\input{chapters/Performance/zusammenfassung.tex}

\pagebreak
\section{Fazit}\label{kap:Fazit}
\input{chapters/Fazit.tex}
\pagebreak
\section{Ausblick}\label{kap:ausblick}
\subsection{Etablierung einer Composition Root}\label{sec:EtablierungEinerKompositionroot}
\input{chapters/Ausblick/EtablierungEinerKompositionroot.tex}
\subsection{Dynamisches Rendern von Schrift}
Ein Punkt, der während der Implementierung der nebenläufigen Architektur im Bereich \ac{gui} aufgefallen ist, ist die Art und Weise, wie in der Blocklib Text gerendert wird. \textcite{Vries2020} beschreibt die Nutzung von sogenannten \emph{Bitmap-Fonts} als die typische Rendermethode für Text. Bei dieser Methode werden alle zu zeichnenden Zeichen in einer Textur gespeichert. Ein Beispiel für eine solche Textur ist in Abbildung~\ref{fig:bitmapfont} dargestellt.
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=.8\textwidth]{ExportedFont.png}
	\caption[Bitmap-Font der Schrift Consolas.]{Bitmap-Font der Schrift Consolas, erzeugt mit \enquote{Codehead's Bitmap Font Generator}~\cite{Codehead2015}.}\label{fig:bitmapfont}
\end{figure}
Durch die Textur sind Schriftart und Schriftgröße festgelegt. Möchte man diese ändern, wird eine weitere Textur benötigt. Um Text zu rendern wird für jeden Buchstaben die entsprechende Stelle im Bitmap-Font ausgewählt und gerendert. In der Blocklib wird statt eines Bitmap-Fonts ein Rendersystem von Java, das Abstract Window Toolkit (AWT), genutzt. Damit werden zur Laufzeit mit der \ac{cpu} Texturen des gesamten zu rendernden Texts erzeugt und diese dann auf die \ac{gpu} geladen. Soll der Text angezeigt werden, kann nun die gesamte Textur gerendert werden.

Beide Methoden haben bestimmte Vor- und Nachteile. Mit Bitmap-Fonts ist die Wahl der Schriftart durch die gegebenen Texturen eingeschränkt, zudem ist die Geschwindigkeit stark von der Menge der gerenderten Symbole abhängig. Die Methode der Blocklib hat den Vorteil, dass beliebige Fonts und Schriftgrößen genutzt werden können und wenn eine Textur erstellt wurde, ist das Rendern des gesamten Texts sehr schnell. Große Probleme treten allerdings auf, wenn Text gerendert werden soll, der sich schnell ändert, wie beispielsweise ein Zeitanzeige mit Millisekunden oder eine Konsole, in die Text geschrieben werden kann. Jedes mal, wenn sich der zu rendernde Text ändert muss zuerst auf der \ac{cpu} eine neue entsprechende Textur gerendert werden, dann muss diese auf die \ac{gpu} geladen werden, damit sie schließlich angezeigt werden kann. In den eben genannte Fällen passiert das sehr häufig, was zu einer hohen Auslastung der \ac{cpu} und des \ac{gpu}-Busses (die Leitung, über die Daten an die \ac{gpu} geschickt werden können) führt.

Es ist aber möglich, die Vorteil beider Methoden zu kombinieren. Da Spiele inzwischen häufig verschiedene Schriften und Schriftgrößen nutzen, werden Bibliotheken wie FreeType~\cite{TheFreeTypeProject,Vries2020} genutzt, um zur Laufzeit Texturen von Schriften zu erzeugen, die dann als Bitmap-Font auf die \ac{gpu} geladen und dann genutzt werden können. Dieser Ansatz kann auch in der Blocklib gewählt werden, sodass AWT nicht mehr genutzt wird, um einen bestimmten Text zu rendern, sondern, um einen Bitmap-Font zu erzeugen. Zusätzlich müssen die damit verbundenen nötigen Schriftdaten, wie Breite der einzelnen Zeichen und weitere typografisch wichtige Metriken erzeugt und gespeichert werden. Alternativ wäre es möglich zwei getrennte Systeme anzubieten, ein System, das einen Bitmap-Font für sich schnell ändernde Texte nutzt, und eins, das wie bisher Texturen für lange sich selten ändernde Texte erzeugt, sodass diese gesammelt angezeigt werden können. Das zweite bestehende System kann auch dann weiter genutzt werden, wenn die Bitmap-Fonts dynamisch erzeugt werden.

\subsection{Weitere Verbesserungen der nebenläufigen Architektur}
Während der Arbeit an der nebenläufigen Architektur sind einige Möglichkeiten zum Vorschein gekommen, die implementiert werden können, um das nun bestehende System weiter zu verbessern.
\paragraph{Jobsystem mit PriorityQueue}
Die offensichtlichste Möglichkeit, die nebenläufige Architektur weiter voranzutreiben, ist bereits in der Arbeit angesprochen worden. Zwar bietet das Jobsystem durch die Nutzung von zwei getrennten Thread-Pools die Möglichkeit, Tasks mit unterschiedlichen Prioritäten zu definieren, allerdings hat das aktuell nur den Effekt, dass sich die Tasks durch die unterschiedlichen Thread-Pools nicht behindern. Tasks mit höherer Priorität werden nicht eher ausgeführt als Task mit niedriger Priorität. Außerdem ist durch die aktuelle Implementierung die Möglichkeit verloren gegangen, die Anzahl der Java-Threads genau auf die Anzahl der Hardware-Threads anzupassen. Das kann wie bereits in den Grundlagen beschrieben dazu führen, dass die Threads sich durch häufige Kontextwechsel gegenseitig behindern.

Die Lösung dafür ist die Implementierung eines Jobsystems mit einer funktionierenden Priorisierung über eine Prioritäts-Warteschlange für die Tasks. Damit wird eine tatsächliche Priorisierung von Tasks ermöglicht. Weiter können einfach mehr als nur zwei verschiedene Prioritäten festgelegt werden und die Anzahl der Threads lässt sich wieder exakt abstimmen, sodass die Konkurrenz über die Hardware-Threads möglichst gering ist.

Eine weitere Möglichkeit die nebenläufige Architektur der Blocklib zu verbessern ist, die bestehende Simulation so anzupassen, dass mehr Aufgaben in Jobs ausgelagert werden, sodass die verfügbaren Hardware-Threads besser ausgenutzt werden können. Damit in Verbindung steht die Möglichkeit, verstärkt sogenanntes Batching einzusetzen. Das bedeutet, dass Methoden nicht so tief geschachtelt sind, dass beispielsweise die \code{hit(...)} Methode eines NPCs die \code{checkDefense(...)} Methode des Spielers auslöst und sich eine Methoden-Kaskade \code{decreaseHealth(...)} $\to$ \code{setHealth(...)} $\to$ \code{checkDamageThreshold(...)} $\to$ \code{setBleeding(...)} $\to$ \code{addBloodTexture(...)} $\to$ \code{startHitSound(...)} ergibt, die verschiedenste Systeme betrifft. Stattdessen könnte der Methodenaufruf auch so aussehen \code{hit(...)} $\to$ \code{addToHitlist(...)}. Dann könnten erst alle 
\code{hit(...)}-Methoden, sogar nebenläufig, abgearbeitet werden und eine Liste erzeugen, die dann im nächsten Schritt, wiederum nebenläufig, abgearbeitet werden könnte. 

\paragraph{Thread Affinity}
Ein Thema, das in der Arbeit bisher nicht behandelt worden ist, ist die Frage, auf welchem Hardware-Thread ein Java-Thread schlussendlich ausgeführt wird. Spielentwickler in der Spielindustrie beschäftigen sich aber sehr wohl damit, da dies die Leistung der Software beeinflussen kann~\cite{Gyrling2015}. \emph{Thread Affinity} bezeichnet das Konzept der Zuordnung von Anwendungs-Threads (im Fall der Blocklib Java-Threads) zu Hardware-Threads. Ein bestimmter Java-Thread soll dann beispielsweise immer nur auf Hardware-Thread 1 ausgeführt werden. Thread Affinity kann die Leistung einer Software wie der Blocklib erhöhen, da sie unnötige Kontextwechsel verhindert. Dies lässt sich wie folgt veranschaulichen.

Angenommen, die Blocklib wird auf einem Rechner mit vier Hardware-Threads ausgeführt und besitzt inzwischen ein Jobsystem, das die Anzahl der Java-Threads genau auf die Hardware-Threads anpasst. Dann können prinzipiell Alle erzeugten Java-Threads dauerhaft auf je einem Hardware-Thread ausgeführt werden. Die Blocklib ist allerdings nicht das einzige Programm, das auf dem Rechner ausgeführt wird, daher wird nun einer der Java-Threads durch irgendein anderes Programm unterbrochen (\emph{nicht} das \code{interrupt()} in Java) und soll nun einem neuen Hardware-Thread zugeordnet werden. Da die restlichen Java-Threads der Blocklib bereits sehr lange ausgeführt werden, führt das nun dazu, dass einer der noch laufenden Threads der Blocklib durch den gerade unterbrochenen Thread ausgetauscht wird, was zu noch einem Kontextwechsel führt. Das führt sich kaskadenartig fort, bis alle Java-Threads der Blocklib einmal unterbrochen worden sind. Eine einzige Unterbrechung führt so also zu vier Kontextwechseln. Je höher die Anzahl der Hardware-Threads, desto höher ist auch die Anzahl der unnötigen Kontextwechsel, die jeweils Zeit benötigen.

Dieses Problem lässt sich durch eine feste Zuordnung von Java-Threads zu Hardware-Threads lösen. Tritt nun eine Unterbrechung auf, wird der Thread nicht auf einen anderen Hardware-Thread umgelenkt, sondern wartet einfach, bis der belegte Hardware-Thread wieder frei ist und führt dann die Ausführung fort. Eine Unterbrechung führt zu einem Kontextwechsel, egal wie viele Hardware-Threads vorhanden sind.

Die Implementierung von Thread Affinity ist in Java allerdings nicht trivial, da Java selbst keine Möglichkeiten bietet Java-Threads an Hardware-Threads zu binden. Daher muss diese Funktionalität über das Java Native Interface (JNI) oder Java Native Access (JNA), also mit plattformspezifischen Funktionen, implementiert werden. Es lassen sich allerdings auch Implementierungen und Bibliotheken finden, die diese Funktionalität bereits implementieren~\cite{ChronicleSoftware,Cheremin2011}.

\pagebreak
\markright{Glossar}
\printnoidxglossary[type=main,style=longheader]
\pagebreak
\markright{Akronyme}
\printnoidxglossary[type=acronym,style=longheader]

\pagebreak
\printbibliography[title={Literaturverzeichnis},heading=bibintoc,notkeyword=online]

\pagebreak
\printbibliography[title={Quellenverzeichnis},heading=bibintoc,keyword=online] 


\input{chapters/Anhang/anhang.tex}
\end{document}