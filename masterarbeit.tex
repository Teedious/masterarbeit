% !TeX spellcheck = de_DE
% !LuaLaTeX
\documentclass[12pt,a4paper,listof=totocnumbered,parskip=half]{scrreprt}
\input{preamble}
\addbibresource{Recherche/My Collection.bib}
\defbibheading{Literatur}{\chapter{Literaturverzeichnis}} 
\defbibheading{Quellen}{\section*{Quellenverzeichnis}} 
\input{glossary}
\begin{document}
\input{titelseite}
\null\thispagestyle{empty}\clearpage
\tableofcontents
\chapter{Einleitung}
\section{blocklib}
\section{Nebenläufige Programmierung}
\section{Testen und Testframeworks}

\chapter{Analyse der blocklib}


\chapter{Entwicklung einer Threading API}

\section{Grundlagen zu Threading}
\subsection{Definition von Thread}
Um definieren zu können, was ein Thread ist, müssen zuerst einige weitere Grundbegriffe eingeführt werden. 

Als \emph{Programm} wird in dieser Arbeit die konkrete Niederschrift eines Algorithmus bezeichnet. Die Elemente, aus denen das Programm besteht, werden als \emph{Anweisungen} bezeichnet. Bei der Ausführung eines Programms werden Einzelschritte durchlaufen, diese bezeichnet man als \emph{Aktivitäten}. Eine Sequenz von Aktivitäten, die ein isoliertes Problem abarbeitet, wird \emph{Prozess} genannt. Um diese Definition des Prozessbegriffs von späteren Definitionen abzugrenzen wird er im Folgenden \emph{Rechenprozess} genannt. Die Ausführungseinheit, auf der die Schritte eines Rechenprozesses durchgeführt werden, wird \emph{Prozessor} genannt.\cite{Herrtwich1989}

Wenn ein Programm auf einem Betriebssystem ausgeführt wird, erzeugt das Betriebssystem einen isolierten Adressraum, in dem das Programm ausgeführt wird. Ein Rechenprozess, der auf diese Weise ausgeführt wird, wird als \emph{(System-)Prozess} bezeichnet. Systemprozesse können selbst weitere Systemprozesse starten, wenn das Betriebssystem dies zulässt. Diese Systemprozesse besitzen dann ihren eigenen Adressraum. Die Anzahl der Systemprozesse, die auf einem Rechner laufen, ist meist höher als die Anzahl der Prozessoren des Rechners. Somit können nicht alle Prozesse zur gleichen Zeit laufen. Damit dennoch alle Prozesse voranschreiten können, wechseln moderne Betriebssysteme die Systemprozesse, die auf den Prozessoren des Rechners ausgeführt werden, in schneller Folge. Dabei muss das Betriebssystem einige zu den Systemprozessen gehörende Daten, den \emph{Prozesskontrollblock}, tauschen, sodass der jeweils gerade ausführende Systemprozess seinen eigenen Prozesskontrollblock zur Verfügung hat. Dieser Tausch wird \emph{Kontextwechsel} genannt.\cite{Jobst2018}

Das Speichern und Laden der Prozesskontrollblöcken im Rahmen der Kontextwechsel von Systemprozessen benötigt eine nicht zu vernachlässigende Menge an Zeit. Ein solcher Zeitverbrauch wird auch als \emph{Overhead} bezeichnet. Um den Overhead von Kontextwechseln zu vermindern, bieten moderne Betriebssysteme Systemprozessen die Möglichkeit Rechenprozesse zu erzeugen, die denselben Adressraum wie der erzeugende Systemprozess besitzen. Ein auf diese Art erzeugter Rechenprozess heißt \emph{Thread}. Da die Menge der thread-eigenen Daten, des \emph{Threadkontrollblocks}, deutlich geringer ist als die des Prozesskontrollblocks, erzeugt der Kontextwechsel zwischen Threads einen geringeren Overhead. Zudem können Threads aufgrund des gemeinsamen Adressraums einfacher auf geteilte Ressourcen zugreifen. Das vereinfacht die Kooperation zwischen diesen Rechenprozessen.\cite{Jobst2018}

\subsection{Nebenläufigkeit}
Im vorherigen Abschnitt \TODO{hier ist Vergangenheit}{wurde beschrieben}, dass verschiedene Rechenprozesse unabhängig von einander \enquote{gleichzeit} laufen können. Ein Programm wird häufig als Sequenz von Anweisungen verstanden. In der Definition von Programm in dieser Arbeit wird bewusst auf das Wort Sequenz verzichtet, denn bei vielen Programmen kann es bei bestimmten Anweisungen irrelevant sein, in welcher Reihenfolge sie ausgeführt werden oder ob sie sogar gleichzeitig. Man betrachte das folgende Programm, das die Quadratsumme zweier Ganzzahlen ausgibt: 
\begin{lstlisting}
printSummedSquare(int a, int b){
  x <- a*a
  y <- b*b
  print(x+y)
}
\end{lstlisting}
Es ist leicht zu erkennen, dass es vollkommen egal ist, ob zuerst \code{x} ausgerechnet wird oder \code{y} oder die Berechnungen simultan stattfinden. Einzig der Ausgabebefehl in Zeile 4 muss ausgeführt nachdem \code{x} und \code{y} berechnet wurden. Paare oder Gruppen von Anweisungen, die (wie Zeile 2 und Zeile 3 des obigen Programms) gleichzeitig oder in beliebiger Reihenfolge ausgeführt werden können, heißen \emph{nebenläufig}. Anweisungen können auch beispielsweise durch einen Compiler in mehrere Anweisungen geteilt werden oder schon aus mehreren Anweisungen bestehen (man denke an Funktionsaufrufe). Solche Anweisungen werden \gls{na} genannt. Eine Menge von nebenläufigen Anweisungen von denen mindestens eine \gls{na} ist. Eine Ausführung von Anweisungen ist verzahnt, wenn der Ausführung der Teile einer \glsuseri{na} Anweisung andere Anweisungen ausgeführt werden. Abbildung \ref{fig:concAnweisungen} zeigt, zur Veranschaulichung die verschiedenen Möglichkeiten, wie 
\begin{figure}
\includegraphics[draft,width=\textwidth, height=5cm]{IM_Logo.pdf}
\caption{Mögliche Ausführungen nebenläufiger Anweisungen}\label{fig:concAnweisungen}
\end{figure}

\paragraph{Race Conditions}
\subsection{Threading in Java}
\section{Anforderungen der blocklib an eine Threading API}
\subsection{Kontrolle über Threads an einer Stelle}
\subsection{Verteilung von Berechnungen an Worker Threads}
\subsection{Verhinderung von Livenessproblemen durch Archtektur}
\subsection{Einfaches starten von Hintergrundtasks und einmaligen Aufgaben}
\section{Design der Threading API}
\section{Implementierung der Threading API}
\section{Integration und Performanceanalyse}

\chapter{Entwicklung einer Test API}
\section{Grundlagen zu Testframeworks}
\subsection{Testen mittels OpenGL}
\subsection{JUnit}
\section{Anforderungen der blocklib an eine Test API}
\subsection{Verfügbarkeit von sinnvollen Highlevel Testfunktionen}
\subsection{Automatisierung der Testung (CI?)}
\subsection{Gute Dokumentation der Testmethodik}
\section{Design der Threading API}
\section{Implementierung der Threading API}
\section{Integration und Performanceanalyse}

\chapter{Fazit und Ausblick}

\printnoidxglossaries

\printbibliography[title={Literaturverzeichnis},heading=bibintoc,notkeyword=online]

\printbibliography[title={Quellenverzeichnis},heading=bibintoc,keyword=online] 


\end{document}